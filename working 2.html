<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Topological Acoustics in RF Devices | From WiFi to Quantum Computing</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;900&family=JetBrains+Mono:wght@400;500;600&display=swap');
        
        body {
            font-family: 'Inter', sans-serif;
            background: #0a0a0f;
            overflow: hidden;
            color: #ffffff;
        }
        
        #canvas { width: 100vw; height: 100vh; display: block; }
        
        .header {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            z-index: 100;
            pointer-events: none;
        }
        
        .title {
            font-size: 1.4em;
            font-weight: 700;
            color: #f59e0b;
            letter-spacing: 2px;
            text-transform: uppercase;
            margin-bottom: 4px;
            opacity: 0;
            animation: fadeIn 1s ease forwards 0.3s;
            text-shadow: 0 2px 10px rgba(245, 158, 11, 0.3);
        }
        
        @keyframes fadeIn {
            to { opacity: 1; }
        }
        
        .subtitle {
            font-size: 0.7em;
            color: #9ca3af;
            font-weight: 600;
            letter-spacing: 2px;
            text-transform: uppercase;
            opacity: 0;
            animation: fadeIn 1s ease forwards 0.6s;
        }
        
        .info-panel {
            position: absolute;
            top: 30px;
            left: 20px;
            background: rgba(10, 10, 15, 0.95);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(245, 158, 11, 0.3);
            border-left: 3px solid #f59e0b;
            padding: 12px;
            border-radius: 3px;
            min-width: 220px;
            max-width: 240px;
            z-index: 100;
            opacity: 0;
            animation: fadeIn 1s ease forwards 0.8s;
        }
        
        .info-title {
            font-size: 0.6em;
            color: #f59e0b;
            letter-spacing: 1.5px;
            text-transform: uppercase;
            font-weight: 700;
            margin-bottom: 8px;
        }
        
        .info-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
            font-size: 0.7em;
        }
        
        .info-label {
            color: #d1d5db;
            font-weight: 500;
        }
        
        .info-value {
            color: #f59e0b;
            font-family: 'JetBrains Mono', monospace;
            font-weight: 600;
            font-size: 0.85em;
        }
        
        .equation-panel {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(10, 10, 15, 0.95);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(139, 92, 246, 0.4);
            padding: 10px 20px;
            border-radius: 3px;
            text-align: center;
            z-index: 100;
            font-family: 'JetBrains Mono', monospace;
            opacity: 0;
            animation: fadeIn 1s ease forwards 1s;
            max-width: 700px;
        }
        
        .eq-label {
            font-size: 0.55em;
            color: #8b5cf6;
            letter-spacing: 1.5px;
            text-transform: uppercase;
            margin-bottom: 4px;
            font-weight: 600;
        }
        
        .eq-math {
            font-size: 0.8em;
            color: #ffffff;
            line-height: 1.4;
        }
        
        .description-panel {
            position: absolute;
            bottom: 140px;
            left: 20px;
            background: rgba(10, 10, 15, 0.9);
            backdrop-filter: blur(15px);
            border: 1px solid rgba(34, 197, 94, 0.3);
            border-left: 3px solid #22c55e;
            padding: 10px 12px;
            border-radius: 3px;
            max-width: 280px;
            z-index: 100;
            opacity: 0;
            animation: fadeIn 1s ease forwards 1.2s;
        }
        
        .desc-text {
            font-size: 0.85em;
            color: #d1d5db;
            line-height: 1.5;
        }
        
        .process-panel {
            position: absolute;
            top: 30px;
            right: 20px;
            text-align: right;
            z-index: 100;
            pointer-events: none;
        }
        
        .process-step {
            background: rgba(139, 92, 246, 0.12);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(139, 92, 246, 0.25);
            padding: 4px 10px;
            margin-bottom: 3px;
            border-radius: 2px;
            font-size: 0.65em;
            font-weight: 600;
            color: #c4b5fd;
            letter-spacing: 0.3px;
            opacity: 0;
            animation: slideIn 0.6s ease forwards;
            transition: all 0.3s ease;
        }
        
        .process-step.active {
            background: rgba(245, 158, 11, 0.25);
            border-color: rgba(245, 158, 11, 0.5);
            color: #fcd34d;
        }
        
        @keyframes slideIn {
            from { opacity: 0; transform: translateX(15px); }
            to { opacity: 1; transform: translateX(0); }
        }
        
        .process-step:nth-child(1) { animation-delay: 1s; }
        .process-step:nth-child(2) { animation-delay: 1.1s; }
        .process-step:nth-child(3) { animation-delay: 1.2s; }
        .process-step:nth-child(4) { animation-delay: 1.3s; }
        .process-step:nth-child(5) { animation-delay: 1.4s; }
        .process-step:nth-child(6) { animation-delay: 1.5s; }
        
        .stage-indicator {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 6px;
            z-index: 100;
        }
        
        .stage-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: rgba(245, 158, 11, 0.2);
            border: 1px solid rgba(245, 158, 11, 0.3);
            transition: all 0.3s ease;
            cursor: pointer;
        }
        
        .stage-dot:hover {
            background: rgba(245, 158, 11, 0.4);
            border-color: rgba(245, 158, 11, 0.6);
        }
        
        .stage-dot.active {
            background: #f59e0b;
            border-color: #f59e0b;
            box-shadow: 0 0 10px rgba(245, 158, 11, 0.5);
            transform: scale(1.3);
        }
        
        .author-badge {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: transparent;
            padding: 8px 16px;
            font-size: 0.9em;
            color: #9ca3af;
            z-index: 100;
            text-align: right;
            font-weight: 500;
            opacity: 0;
            animation: fadeIn 1s ease forwards 1.2s;
        }
        
        .record-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(239, 68, 68, 0.9);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(239, 68, 68, 1);
            color: #ffffff;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Inter', sans-serif;
            font-weight: 600;
            font-size: 0.75em;
            letter-spacing: 0.5px;
            z-index: 150;
            transition: all 0.3s ease;
            text-transform: uppercase;
        }
        
        .record-btn:hover {
            background: rgba(239, 68, 68, 1);
            transform: scale(1.05);
        }
        
        .record-btn.recording {
            background: rgba(34, 197, 94, 0.9);
            border-color: rgba(34, 197, 94, 1);
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        .recording-timer {
            position: absolute;
            top: 70px;
            right: 20px;
            background: rgba(10, 10, 15, 0.95);
            backdrop-filter: blur(15px);
            border: 2px solid rgba(34, 197, 94, 1);
            color: #22c55e;
            padding: 8px 16px;
            border-radius: 5px;
            font-family: 'JetBrains Mono', monospace;
            font-weight: 600;
            font-size: 0.8em;
            z-index: 150;
            display: none;
        }
        
        .recording-timer.active {
            display: block;
        }
        
        .progress-bar {
            position: absolute;
            top: 0;
            left: 0;
            height: 2px;
            background: linear-gradient(90deg, #f59e0b, #ef4444, #8b5cf6);
            z-index: 200;
            transition: width 0.3s ease;
        }
        
        .label-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 50;
        }
        
        .component-label {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-left: 2px solid #f59e0b;
            padding: 4px 8px;
            border-radius: 2px;
            font-size: 0.68em;
            color: #ffffff;
            white-space: nowrap;
            opacity: 0;
            transform: translate(-50%, -50%);
            transition: opacity 0.3s ease;
            animation: labelFadeIn 0.8s ease forwards;
        }
        
        .component-label .label-title {
            color: #f59e0b;
            font-weight: 600;
            font-size: 1.1em;
        }
        
        .component-label .label-desc {
            color: #9ca3af;
            font-size: 0.9em;
            margin-top: 1px;
        }
        
        @keyframes labelFadeIn {
            to { opacity: 1; transform: translateY(0); }
        }
        
        .component-label:nth-child(1) { animation-delay: 1.3s; }
        .component-label:nth-child(2) { animation-delay: 1.5s; }
        .component-label:nth-child(3) { animation-delay: 1.7s; }
        .component-label:nth-child(4) { animation-delay: 1.9s; }
        .component-label:nth-child(5) { animation-delay: 2.1s; }
        .component-label:nth-child(6) { animation-delay: 2.3s; }
        .component-label:nth-child(7) { animation-delay: 2.5s; }
        
        /* Title Slide Styles */
        .title-slide {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #0a0a0f;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 1s ease, visibility 1s ease;
        }
        
        .title-slide.hidden {
            opacity: 0;
            visibility: hidden;
        }
        
        #titleCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }
        
        .title-slide-content {
            text-align: center;
            max-width: 1200px;
            padding: 40px;
            position: relative;
            z-index: 1;
        }
        
        .main-title {
            font-size: 3.2em;
            font-weight: 700;
            color: #ffffff;
            margin-bottom: 40px;
            line-height: 1.3;
            letter-spacing: 1px;
            opacity: 0;
            animation: titleFadeIn 1.2s ease forwards 0.3s;
            text-shadow: 0 2px 15px rgba(245, 158, 11, 0.4), 0 0 60px rgba(245, 158, 11, 0.2);
            font-family: 'Inter', sans-serif;
        }
        
        .main-title span {
            background: linear-gradient(135deg, #f59e0b 0%, #fbbf24 50%, #fcd34d 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        @keyframes titleFadeIn {
            from { 
                opacity: 0; 
                transform: translateY(30px);
            }
            to { 
                opacity: 1; 
                transform: translateY(0);
            }
        }
        
        .presenter-section {
            margin-top: 60px;
            padding-top: 40px;
            border-top: 2px solid rgba(245, 158, 11, 0.3);
            opacity: 0;
            animation: titleFadeIn 1.2s ease forwards 1s;
        }
        
        .presenter-name {
            font-size: 2em;
            font-weight: 700;
            color: #f59e0b;
            margin-bottom: 15px;
            letter-spacing: 0.5px;
        }
        
        .presenter-title {
            font-size: 1.3em;
            font-weight: 600;
            color: #e5e7eb;
            margin-bottom: 10px;
        }
        
        .presenter-affiliation {
            font-size: 1.1em;
            font-weight: 500;
            color: #9ca3af;
            line-height: 1.6;
            max-width: 700px;
            margin: 0 auto;
        }
        
        .vfx-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: hidden;
        }
        
        .circuit-line {
            position: absolute;
            background: linear-gradient(90deg, transparent, #f59e0b, transparent);
            height: 1px;
            opacity: 0.6;
            animation: circuitFlow 8s linear infinite;
        }
        
        @keyframes circuitFlow {
            0% { transform: translateX(-100%); opacity: 0; }
            10% { opacity: 0.6; }
            90% { opacity: 0.6; }
            100% { transform: translateX(100vw); opacity: 0; }
        }
        
        .particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: #f59e0b;
            border-radius: 50%;
            box-shadow: 0 0 10px #f59e0b, 0 0 20px rgba(245, 158, 11, 0.5);
            animation: particleFloat 15s linear infinite;
        }
        
        @keyframes particleFloat {
            0% { transform: translate(0, 0) scale(0); opacity: 0; }
            10% { opacity: 1; transform: scale(1); }
            90% { opacity: 1; }
            100% { transform: translate(var(--tx), var(--ty)) scale(0); opacity: 0; }
        }
        
        .wave-ring {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border: 2px solid rgba(245, 158, 11, 0.3);
            border-radius: 50%;
            animation: waveExpand 6s ease-out infinite;
        }
        
        @keyframes waveExpand {
            0% { width: 50px; height: 50px; opacity: 0.8; }
            100% { width: 1200px; height: 1200px; opacity: 0; }
        }
        
        .hex-grid {
            position: absolute;
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.1), rgba(245, 158, 11, 0.1));
            clip-path: polygon(30% 0%, 70% 0%, 100% 50%, 70% 100%, 30% 100%, 0% 50%);
            border: 1px solid rgba(245, 158, 11, 0.2);
            animation: hexFloat 20s ease-in-out infinite;
        }
        
        @keyframes hexFloat {
            0%, 100% { transform: translate(0, 0) rotate(0deg); opacity: 0.3; }
            50% { transform: translate(var(--hx), var(--hy)) rotate(180deg); opacity: 0.6; }
        }
        
        .glow-orb {
            position: absolute;
            width: 200px;
            height: 200px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(245, 158, 11, 0.3), transparent 70%);
            filter: blur(40px);
            animation: orbPulse 4s ease-in-out infinite;
        }
        
        @keyframes orbPulse {
            0%, 100% { transform: scale(1); opacity: 0.5; }
            50% { transform: scale(1.3); opacity: 0.8; }
        }
        
        .data-stream {
            position: absolute;
            width: 2px;
            height: 100px;
            background: linear-gradient(180deg, transparent, #8b5cf6, transparent);
            opacity: 0.7;
            animation: dataFlow 5s linear infinite;
        }
        
        @keyframes dataFlow {
            0% { transform: translateY(-100vh); opacity: 0; }
            10% { opacity: 0.7; }
            90% { opacity: 0.7; }
            100% { transform: translateY(100vh); opacity: 0; }
        }
        
        .decorative-line {
            width: 100px;
            height: 3px;
            background: linear-gradient(90deg, transparent, #f59e0b, transparent);
            margin: 30px auto;
            opacity: 0;
            animation: titleFadeIn 1.2s ease forwards 0.8s;
        }
    </style>
</head>
<body>
    <!-- Title Slide -->
    <div class="title-slide" id="titleSlide" onclick="startPresentation()" style="cursor: pointer;">
        <canvas id="titleCanvas"></canvas>
        
        <div class="title-slide-content">
            <h1 class="main-title">
                <span>Topological Acoustics</span> in RF Devices:<br>
                From WiFi to Quantum Computing
            </h1>
            
            <div class="decorative-line"></div>
            
            <div class="presenter-section">
                <div class="presenter-name">Samarjith Biswas, PhD</div>
                <div class="presenter-title">Research Scientist III</div>
                <div class="presenter-affiliation">
                    New Frontiers of Sound (NewFoS) Science<br>
                    & Technology Center
                </div>
            </div>
        </div>
    </div>
    
    <!-- Main Content -->
    <div class="progress-bar" id="progressBar"></div>
    <canvas id="canvas"></canvas>
    
    <div class="header">
        <div class="title" id="mainTitle">Wireless Signal Processing</div>
        <div class="subtitle" id="mainSubtitle">RF Front-End Technology</div>
    </div>
    
    <div class="info-panel" id="infoPanel">
        <div class="info-title">Technical Parameters</div>
        <div id="infoContent"></div>
    </div>
    
    <div class="equation-panel" id="equationPanel">
        <div class="eq-label">Key Physics</div>
        <div class="eq-math" id="equation"></div>
    </div>
    
    <div class="description-panel" id="descPanel">
        <div class="desc-text" id="description"></div>
    </div>
    
    <div class="process-panel" id="processPanel"></div>
    
    <div class="stage-indicator" id="stageIndicator"></div>
    
    <div class="label-container" id="labelContainer"></div>
    
    <div class="author-badge">
        Visualized by Dr. Samarjith Biswas
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Initialize Three.js scene for title slide
        let titleScene, titleCamera, titleRenderer;
        let titleAnims = [];
        
        function initTitleSlide() {
            const titleCanvas = document.getElementById('titleCanvas');
            
            titleScene = new THREE.Scene();
            titleCamera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 1000);
            titleRenderer = new THREE.WebGLRenderer({ 
                canvas: titleCanvas, 
                antialias: true,
                alpha: true
            });
            titleRenderer.setSize(window.innerWidth, window.innerHeight);
            titleRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            
            const titleGroup = new THREE.Group();
            titleScene.add(titleGroup);
            
            // Ambient light
            const ambient = new THREE.AmbientLight(0x404050, 0.6);
            titleGroup.add(ambient);
            
            // Main directional light
            const mainLight = new THREE.DirectionalLight(0xffffff, 1.5);
            mainLight.position.set(50, 80, 50);
            titleGroup.add(mainLight);
            
            // Point lights
            for (let i = 0; i < 3; i++) {
                const light = new THREE.PointLight(0xffffff, 1.5, 200);
                titleGroup.add(light);
                titleAnims.push({ type: 'light', obj: light, i });
            }
            
            // Large rotating rings (blue theme)
            for (let i = 0; i < 3; i++) {
                const ringGeom = new THREE.TorusGeometry(50 + i * 20, 2, 16, 100);
                const ringMat = new THREE.MeshStandardMaterial({
                    color: 0x2563eb,
                    emissive: 0x1e40af,
                    emissiveIntensity: 0.3 - i * 0.08,
                    metalness: 0.9,
                    roughness: 0.1,
                    transparent: true,
                    opacity: 0.4 - i * 0.1
                });
                const ring = new THREE.Mesh(ringGeom, ringMat);
                ring.position.set(0, 0, -30 - i * 10);
                ring.rotation.x = Math.PI / 3;
                titleGroup.add(ring);
                titleAnims.push({ type: 'introRing', obj: ring, idx: i });
            }
            
            // Floating particles
            for (let i = 0; i < 25; i++) {
                const sphereGeom = new THREE.SphereGeometry(1.5, 16, 16);
                const sphereMat = new THREE.MeshStandardMaterial({
                    color: i % 2 === 0 ? 0x3b82f6 : 0x8b5cf6,
                    emissive: i % 2 === 0 ? 0x3b82f6 : 0x8b5cf6,
                    emissiveIntensity: 0.6,
                    metalness: 0.8,
                    roughness: 0.2
                });
                const sphere = new THREE.Mesh(sphereGeom, sphereMat);
                
                const radius = 40 + Math.random() * 40;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                
                sphere.position.set(
                    radius * Math.sin(phi) * Math.cos(theta),
                    radius * Math.sin(phi) * Math.sin(theta),
                    radius * Math.cos(phi) - 40
                );
                
                titleGroup.add(sphere);
                titleAnims.push({ type: 'introSphere', obj: sphere, i, radius, theta, phi });
            }
            
            // Wave rings (orange/amber)
            for (let i = 0; i < 5; i++) {
                const waveGeom = new THREE.TorusGeometry(15 + i * 8, 0.5, 8, 64);
                const waveMat = new THREE.MeshStandardMaterial({
                    color: 0xf59e0b,
                    emissive: 0xf59e0b,
                    emissiveIntensity: 0.5,
                    transparent: true,
                    opacity: 0.3 - i * 0.05,
                    metalness: 0.6,
                    roughness: 0.2
                });
                const wave = new THREE.Mesh(waveGeom, waveMat);
                wave.position.set(-35, -20, -15);
                wave.rotation.y = Math.PI / 4;
                titleGroup.add(wave);
                titleAnims.push({ type: 'introWave', obj: wave, i });
            }
            
            // Abstract geometric accent (purple wireframe)
            const accentGeom = new THREE.IcosahedronGeometry(12, 1);
            const accentMat = new THREE.MeshStandardMaterial({
                color: 0x8b5cf6,
                emissive: 0x7c3aed,
                emissiveIntensity: 0.4,
                metalness: 0.9,
                roughness: 0.1,
                transparent: true,
                opacity: 0.3,
                wireframe: true
            });
            const accent = new THREE.Mesh(accentGeom, accentMat);
            accent.position.set(40, 25, -25);
            titleGroup.add(accent);
            titleAnims.push({ type: 'introAccent', obj: accent });
            
            titleCamera.position.set(0, 0, 80);
            titleCamera.lookAt(0, 0, 0);
            
            animateTitleSlide();
        }
        
        function animateTitleSlide() {
            requestAnimationFrame(animateTitleSlide);
            const t = Date.now() * 0.001;
            
            titleAnims.forEach(a => {
                switch(a.type) {
                    case 'introRing':
                        a.obj.rotation.z = t * (0.1 + a.idx * 0.03);
                        a.obj.rotation.y = t * 0.05;
                        a.obj.material.emissiveIntensity = (0.3 - a.idx * 0.08) + Math.sin(t * 1.5 + a.idx) * 0.1;
                        break;
                        
                    case 'introSphere':
                        const orbitSpeed = 0.08 + (a.i % 7) * 0.015;
                        const newTheta = a.theta + t * orbitSpeed;
                        const newPhi = a.phi + Math.sin(t * 0.2 + a.i) * 0.08;
                        a.obj.position.set(
                            a.radius * Math.sin(newPhi) * Math.cos(newTheta),
                            a.radius * Math.sin(newPhi) * Math.sin(newTheta),
                            a.radius * Math.cos(newPhi) - 40
                        );
                        a.obj.material.emissiveIntensity = 0.5 + Math.sin(t * 2.5 + a.i) * 0.15;
                        break;
                        
                    case 'introWave':
                        const introWaveScale = 1 + Math.sin(t * 1.8 - a.i * 0.4) * 0.08;
                        a.obj.scale.setScalar(introWaveScale);
                        a.obj.rotation.z = t * 0.25;
                        a.obj.material.opacity = (0.3 - a.i * 0.05) * (0.6 + Math.sin(t * 1.8 - a.i * 0.4) * 0.4);
                        break;
                        
                    case 'introAccent':
                        a.obj.rotation.x = t * 0.2;
                        a.obj.rotation.y = t * 0.15;
                        a.obj.material.emissiveIntensity = 0.4 + Math.sin(t * 2) * 0.2;
                        break;
                        
                    case 'light':
                        const lr = 100;
                        const la = t * 0.12 + a.i * Math.PI * 0.66;
                        a.obj.position.set(Math.cos(la) * lr, 60 + Math.sin(t * 0.4 + a.i) * 15, Math.sin(la) * lr);
                        a.obj.intensity = 1.5 + Math.sin(t * 1.5 + a.i) * 0.3;
                        break;
                }
            });
            
            titleRenderer.render(titleScene, titleCamera);
        }
        
        // Initialize on load
        window.addEventListener('DOMContentLoaded', initTitleSlide);
        
        // Title slide function
        function startPresentation() {
            const titleSlide = document.getElementById('titleSlide');
            titleSlide.classList.add('hidden');
            setTimeout(() => {
                titleSlide.style.display = 'none';
            }, 1000);
        }
        
        let scene, camera, renderer;
        let currentIndex = 0;
        let anims = [];
        let currentGroup;
        let labelTracking = [];
        
        // Recording variables
        let mediaRecorder;
        let recordedChunks = [];
        let isRecording = false;
        let recordingStartTime = 0;
        let stageDuration = 45000; // 45 seconds per stage
        let autoAdvanceTimer = null;
        let timerInterval = null;
        let stageStartTime = 0;
        
        // Material definitions for realistic rendering
        const materials = {
            copper: () => new THREE.MeshStandardMaterial({
                color: 0xb87333,
                roughness: 0.3,
                metalness: 0.9
            }),
            gold: () => new THREE.MeshStandardMaterial({
                color: 0xffd700,
                roughness: 0.2,
                metalness: 0.95
            }),
            aluminum: () => new THREE.MeshStandardMaterial({
                color: 0xc0c0c0,
                roughness: 0.35,
                metalness: 0.85
            }),
            silicon: () => new THREE.MeshStandardMaterial({
                color: 0x4a5568,
                roughness: 0.6,
                metalness: 0.3
            }),
            piezo: () => new THREE.MeshStandardMaterial({
                color: 0x7c3aed,
                roughness: 0.4,
                metalness: 0.4,
                transparent: true,
                opacity: 0.85
            }),
            gst: () => new THREE.MeshStandardMaterial({
                color: 0x1e3a5f,
                roughness: 0.5,
                metalness: 0.35
            }),
            pcb: () => new THREE.MeshStandardMaterial({
                color: 0x065f46,
                roughness: 0.7,
                metalness: 0.1
            })
        };
        
        const stages = [
            {
                title: "Mobile Wireless Architecture",
                subtitle: "Signal Path from Tower to Your Phone",
                info: [
                    { label: "WiFi Bands", value: "2.4/5/6 GHz" },
                    { label: "5G Bands", value: "Sub-6 GHz" },
                    { label: "Filters/Phone", value: "100+" },
                    { label: "Market Size", value: "$15B+" },
                    { label: "Wave Speed", value: "~3500 m/s" }
                ],
                equation: "Acoustic λ = v/f ≈ μm | EM λ = c/f ≈ cm → 10,000× size reduction",
                description: "Wireless signals travel from cell towers and WiFi routers to your smartphone. Inside, over 100 acoustic wave filters process these signals—using sound waves that travel 100,000× slower than light, enabling extreme miniaturization.",
                process: [
                    "Cell Tower TX",
                    "WiFi Router",
                    "Antenna Reception",
                    "RF Front-End",
                    "Signal Filtering",
                    "Baseband Processing"
                ]
            },
            {
                title: "Smartphone RF Architecture",
                subtitle: "Inside Your Phone's Communication System",
                info: [
                    { label: "Antennas", value: "4-8 elements" },
                    { label: "RF Modules", value: "Multiple" },
                    { label: "Filter Type", value: "SAW/BAW" },
                    { label: "Size", value: "<1 mm²" },
                    { label: "Bands", value: "20-40+" }
                ],
                equation: "S₂₁(f) = Transfer Function | IL = -20log|S₂₁| | Q = f₀/Δf",
                description: "Modern smartphones contain sophisticated RF front-end modules with multiple antennas strategically placed around the device edges. Each antenna connects to acoustic wave filters that separate frequency bands with exceptional precision.",
                process: [
                    "MIMO Antennas",
                    "RF Front-End",
                    "Duplexers",
                    "Band Filters",
                    "LNA/PA",
                    "Transceiver IC"
                ]
            },
            {
                title: "SAW Filter Architecture",
                subtitle: "Interdigital Transducers on Piezoelectric Substrate",
                info: [
                    { label: "Substrate", value: "LiNbO₃/LiTaO₃" },
                    { label: "Wave Type", value: "Rayleigh/SH" },
                    { label: "Velocity", value: "~3,500 m/s" },
                    { label: "IDT Pitch", value: "λ/2 ~ μm" },
                    { label: "Q Factor", value: "500-1000" }
                ],
                equation: "Piezoelectric: D = εE + eS | T = cS - eE | f₀ = v/(2p)",
                description: "Surface Acoustic Wave filters use copper interdigital transducers (IDTs) on piezoelectric substrates. The IDT finger spacing defines the resonant frequency. Between the IDTs lies the region where topological phononic crystals can be integrated.",
                process: [
                    "Input IDT",
                    "Piezoelectric Conv.",
                    "SAW Generation",
                    "Wave Propagation",
                    "Output IDT",
                    "Electrical Output"
                ]
            },
            {
                title: "SAW Filter Operation",
                subtitle: "Signal Filtering Through Phononic Crystal",
                info: [
                    { label: "Input", value: "RF Signal" },
                    { label: "Conversion", value: "EM → Acoustic" },
                    { label: "Filtering", value: "Phononic Crystal" },
                    { label: "Output", value: "Filtered RF" },
                    { label: "Insertion Loss", value: "< 2 dB" }
                ],
                equation: "RF → Acoustic → Phononic Filter → RF | IL = -20log|S₂₁|",
                description: "Close-up view of SAW filter operation showing the complete signal path. RF signals are converted to acoustic waves by the input IDT, propagate through the phononic crystal region for frequency-selective filtering, and are converted back to RF by the output IDT.",
                process: [
                    "RF Input → IDT",
                    "Piezoelectric Conv.",
                    "SAW Propagation",
                    "Phononic Filtering",
                    "Output IDT",
                    "Filtered RF Out"
                ]
            },
            {
                title: "Topological Phononic Crystal",
                subtitle: "GST-Based Valley Hall Metamaterial",
                info: [
                    { label: "Material", value: "Ge₂Sb₂Te₅" },
                    { label: "Lattice", value: "Hexagonal" },
                    { label: "Topology", value: "Valley Hall" },
                    { label: "Band Gap", value: "~GHz" },
                    { label: "Protection", value: "Topological" }
                ],
                equation: "H = vᴅ(kₓσₓ + kᵧσᵧ) + Δmσᵤ | Berry Phase = π | Valley Chern = ±1/2",
                description: "A hexagonal phononic crystal with GST phase-change inclusions embedded in the host matrix creates topologically protected edge states. Breaking inversion symmetry opens a band gap at the Dirac points, enabling robust wave transport immune to defects.",
                process: [
                    "Hexagonal Array",
                    "Embedded GST",
                    "Dirac Cone",
                    "Band Inversion",
                    "Edge States",
                    "Valley Polarization"
                ]
            },
            {
                title: "Topological Edge State Propagation",
                subtitle: "Unidirectional Transport & Backscattering Immunity",
                info: [
                    { label: "Edge States", value: "Topological" },
                    { label: "Direction", value: "Unidirectional" },
                    { label: "Backscatter", value: "<-40 dB" },
                    { label: "Path Loss", value: "Defect-Immune" },
                    { label: "Robustness", value: "Guaranteed" }
                ],
                equation: "σₓᵧ = (e²/h)·C | Chern: ∮dk·A(k) = 2πC | Backscatter: Protected",
                description: "Topological edge states propagate unidirectionally along domain boundaries, immune to backscattering from defects, sharp corners, and disorder. Waves can route left, right, or both directions depending on the interface configuration, with topological protection preventing reflection.",
                process: [
                    "Edge State Launch",
                    "Unidirectional Flow",
                    "Defect Encounter",
                    "No Backscatter",
                    "Corner Navigation",
                    "Multi-path Routing"
                ]
            },
            {
                title: "Frequency-Selective Routing",
                subtitle: "Unidirectional Wave Transport via Topology",
                info: [
                    { label: "Mechanism", value: "Valley Hall" },
                    { label: "Direction", value: "Frequency-dep." },
                    { label: "Contrast", value: ">35 dB" },
                    { label: "Backscatter", value: "Suppressed" },
                    { label: "Channels", value: "Multiple" }
                ],
                equation: "Valley Index: τᵤ∇ₖΩ(k) | Unidirectional: kᵤ · τᵤ > 0 selects propagation",
                description: "Different frequencies route to different output ports based on valley polarization. The topological edge states enable frequency-selective unidirectional transport without geometric changes—waves navigate corners and defects without backscattering.",
                process: [
                    "Multi-freq Input",
                    "Valley Selection",
                    "Edge Confinement",
                    "Corner Navigation",
                    "Defect Immunity",
                    "Selective Output"
                ]
            },
            {
                title: "Quantum Phononic Applications",
                subtitle: "Qubit Coupling & Quantum State Transfer",
                info: [
                    { label: "Application", value: "Qubit Interface" },
                    { label: "Mechanism", value: "Piezo-Phonon" },
                    { label: "Fidelity", value: ">99%" },
                    { label: "Coherence", value: "~ms" },
                    { label: "Coupling", value: "Strong" }
                ],
                equation: "|ψ⟩_qubit ↔ |n⟩_phonon | g_coupling >> κ_loss | T₂ ~ 1 ms",
                description: "Topological phononic waveguides interface superconducting qubits with quantum memories via piezoelectric transduction. Protected edge states minimize decoherence, enabling high-fidelity quantum state transfer with phonon lifetimes exceeding 10,000× that of superconducting circuits.",
                process: [
                    "Qubit Excitation",
                    "Piezo Transduction",
                    "Phonon Generation",
                    "Topological Routing",
                    "State Transfer",
                    "Quantum Memory"
                ]
            }
        ];
        
        // Component labels for each stage
        const stageLabels = [
            // Stage 0: Mobile Architecture
            [
                { x: '75%', y: '25%', title: 'Cell Tower', desc: '5G/LTE transmission' },
                { x: '18%', y: '55%', title: 'WiFi Router', desc: '2.4/5/6 GHz bands' },
                { x: '48%', y: '48%', title: 'Smartphone', desc: '100+ RF filters inside' },
                { x: '62%', y: '38%', title: 'RF Signals', desc: 'Electromagnetic waves' },
                { x: '32%', y: '58%', title: 'WiFi Signals', desc: '802.11 protocols' }
            ],
            // Stage 1: Smartphone RF
            [
                { x: '55%', y: '22%', title: 'MIMO Antennas', desc: 'Multiple input/output' },
                { x: '38%', y: '42%', title: 'RF Front-End', desc: 'SAW/BAW filters' },
                { x: '55%', y: '48%', title: 'Processor', desc: 'Baseband IC' },
                { x: '35%', y: '55%', title: 'Duplexer', desc: 'TX/RX separation' },
                { x: '70%', y: '35%', title: 'mmWave Module', desc: '28/39 GHz 5G' }
            ],
            // Stage 2: SAW Filter Device
            [
                { x: '22%', y: '38%', title: 'Input IDT', desc: 'Copper fingers' },
                { x: '68%', y: '38%', title: 'Output IDT', desc: 'Signal reception' },
                { x: '50%', y: '58%', title: 'LiNbO₃ Substrate', desc: 'Piezoelectric' },
                { x: '45%', y: '42%', title: 'Phononic Crystal', desc: 'Topological filtering' },
                { x: '50%', y: '32%', title: 'SAW Propagation', desc: 'Surface waves' }
            ],
            // Stage 3: SAW Operation
            [
                { x: '18%', y: '35%', title: 'Input IDT', desc: 'RF → Acoustic' },
                { x: '72%', y: '35%', title: 'Output IDT', desc: 'Acoustic → RF' },
                { x: '50%', y: '48%', title: 'Phononic Filter', desc: 'Frequency selective' },
                { x: '35%', y: '42%', title: 'SAW Waves', desc: 'Propagating' },
                { x: '65%', y: '42%', title: 'Filtered Waves', desc: 'Output signal' }
            ],
            // Stage 4: Topological Crystal
            [
                { x: '20%', y: '38%', title: 'Input IDT', desc: 'Wave generation' },
                { x: '80%', y: '38%', title: 'Output IDT', desc: 'Wave detection' },
                { x: '32%', y: '48%', title: 'Trivial Domain', desc: 'Small inclusions' },
                { x: '68%', y: '48%', title: 'Non-trivial Domain', desc: 'Large inclusions' },
                { x: '50%', y: '45%', title: 'Interface', desc: 'Edge states form here' },
                { x: '50%', y: '55%', title: 'GST Inclusions', desc: 'Embedded in matrix' }
            ],
            // Stage 5: Edge State Propagation
            [
                { x: '25%', y: '50%', title: 'Source', desc: 'Edge state launch' },
                { x: '50%', y: '35%', title: 'Right Propagation', desc: 'Clockwise edge' },
                { x: '50%', y: '65%', title: 'Left Propagation', desc: 'Counter-clockwise' },
                { x: '60%', y: '50%', title: 'Defect Zone', desc: 'No backscattering' },
                { x: '75%', y: '50%', title: 'Sharp Corner', desc: 'Perfect transmission' }
            ],
            // Stage 6: Directional Routing
            [
                { x: '50%', y: '72%', title: 'Input Port', desc: 'Multi-frequency signal' },
                { x: '28%', y: '22%', title: 'Port A (f₁)', desc: 'Frequency 1 output' },
                { x: '72%', y: '22%', title: 'Port B (f₂)', desc: 'Frequency 2 output' },
                { x: '38%', y: '45%', title: 'Left Interface', desc: 'Valley-polarized' },
                { x: '62%', y: '45%', title: 'Right Interface', desc: 'Opposite valley' },
                { x: '50%', y: '48%', title: 'Non-trivial Core', desc: 'Topological routing' }
            ],
            // Stage 7: Quantum
            [
                { x: '50%', y: '18%', title: 'Optical Fiber', desc: 'Photon interface' },
                { x: '50%', y: '35%', title: 'Cryostat', desc: '~10 mK temperature' },
                { x: '50%', y: '48%', title: 'Qubit Chip', desc: 'Superconducting' },
                { x: '38%', y: '52%', title: 'Transmon Qubits', desc: 'Josephson junction' },
                { x: '62%', y: '52%', title: 'Phononic Ring', desc: 'Topological waveguide' },
                { x: '50%', y: '58%', title: 'Piezo Transducers', desc: 'Qubit-phonon coupling' },
                { x: '50%', y: '42%', title: 'Traveling Phonons', desc: 'Quantum state transfer' }
            ]
        ];
        
        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ 
                canvas: document.getElementById('canvas'), 
                antialias: true,
                alpha: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            
            // Create stage indicators
            const stageIndicator = document.getElementById('stageIndicator');
            stages.forEach((_, i) => {
                const dot = document.createElement('div');
                dot.className = 'stage-dot' + (i === 0 ? ' active' : '');
                dot.id = `dot-${i}`;
                dot.onclick = () => loadStage(i);
                stageIndicator.appendChild(dot);
            });
            
            loadStage(0);
            animate();
            
            window.addEventListener('resize', onResize);
            window.addEventListener('keydown', onKey);
        }
        
        function loadStage(index) {
            currentIndex = index;
            const stage = stages[index];
            
            // Update progress bar
            document.getElementById('progressBar').style.width = ((index + 1) / stages.length * 100) + '%';
            
            // Update UI
            document.getElementById('mainTitle').textContent = stage.title;
            document.getElementById('mainSubtitle').textContent = stage.subtitle;
            document.getElementById('equation').textContent = stage.equation;
            document.getElementById('description').textContent = stage.description;
            
            // Update info panel
            const infoContent = document.getElementById('infoContent');
            infoContent.innerHTML = stage.info.map(item => `
                <div class="info-row">
                    <span class="info-label">${item.label}</span>
                    <span class="info-value">${item.value}</span>
                </div>
            `).join('');
            
            // Update process panel
            const processPanel = document.getElementById('processPanel');
            processPanel.innerHTML = stage.process.map((step, i) => `
                <div class="process-step" id="step-${i}">${step}</div>
            `).join('');
            
            // Update stage dots
            stages.forEach((_, i) => {
                document.getElementById(`dot-${i}`).classList.toggle('active', i === index);
            });
            
            // Clear labels and tracking
            const labelContainer = document.getElementById('labelContainer');
            labelContainer.innerHTML = '';
            labelTracking = [];
            
            // Clear and rebuild 3D scene
            if (currentGroup) scene.remove(currentGroup);
            anims = [];
            currentGroup = new THREE.Group();
            scene.add(currentGroup);
            
            // Enhanced lighting setup
            const ambient = new THREE.AmbientLight(0x404050, 0.6);
            currentGroup.add(ambient);
            
            const mainLight = new THREE.DirectionalLight(0xffffff, 1.5);
            mainLight.position.set(50, 80, 50);
            currentGroup.add(mainLight);
            
            for (let i = 0; i < 3; i++) {
                const light = new THREE.PointLight(0xffffff, 1.5, 200);
                currentGroup.add(light);
                anims.push({ type: 'light', obj: light, i });
            }
            
            // Build stage-specific geometry
            switch(index) {
                case 0: buildMobileArchitecture(); break;
                case 1: buildSmartphoneRF(); break;
                case 2: buildSAWFilterDevice(); break;
                case 3: buildSAWOperation(); break;
                case 4: buildTopologicalCrystal(); break;
                case 5: buildEdgeStatePropagation(); break;
                case 6: buildDirectionalRouting(); break;
                case 7: buildQuantum(); break;
            }
        }
        
        function addLabel(object, title, desc, offset = {x: 0, y: 0, z: 0}) {
            const labelContainer = document.getElementById('labelContainer');
            const labelEl = document.createElement('div');
            labelEl.className = 'component-label';
            labelEl.innerHTML = `
                <div class="label-title">${title}</div>
                <div class="label-desc">${desc}</div>
            `;
            labelContainer.appendChild(labelEl);
            
            labelTracking.push({
                object: object,
                element: labelEl,
                offset: offset
            });
        }
        
        function buildMobileArchitecture() {
            const group = currentGroup;
            
            // Cell tower - realistic lattice structure
            const towerHeight = 80;
            const towerWidth = 6;
            const towerBaseY = -35;
            
            // Tower legs (3 legs in triangular arrangement)
            for (let i = 0; i < 3; i++) {
                const angle = (i / 3) * Math.PI * 2;
                const legGeom = new THREE.CylinderGeometry(0.4, 0.5, towerHeight, 8);
                const legMat = new THREE.MeshStandardMaterial({
                    color: 0xcccccc,
                    metalness: 0.9,
                    roughness: 0.3
                });
                const leg = new THREE.Mesh(legGeom, legMat);
                leg.position.set(
                    35 + Math.cos(angle) * towerWidth,
                    towerBaseY + towerHeight / 2,
                    -30 + Math.sin(angle) * towerWidth
                );
                leg.castShadow = true;
                group.add(leg);
            }
            
            // Horizontal cross-braces
            for (let level = 0; level < 8; level++) {
                const y = towerBaseY + (level / 7) * towerHeight;
                for (let i = 0; i < 3; i++) {
                    const angle1 = (i / 3) * Math.PI * 2;
                    const angle2 = ((i + 1) / 3) * Math.PI * 2;
                    
                    const start = new THREE.Vector3(
                        35 + Math.cos(angle1) * towerWidth,
                        y,
                        -30 + Math.sin(angle1) * towerWidth
                    );
                    const end = new THREE.Vector3(
                        35 + Math.cos(angle2) * towerWidth,
                        y,
                        -30 + Math.sin(angle2) * towerWidth
                    );
                    
                    const distance = start.distanceTo(end);
                    const braceGeom = new THREE.CylinderGeometry(0.15, 0.15, distance, 8);
                    const braceMat = new THREE.MeshStandardMaterial({
                        color: 0xaaaaaa,
                        metalness: 0.8,
                        roughness: 0.4
                    });
                    const brace = new THREE.Mesh(braceGeom, braceMat);
                    
                    const mid = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);
                    brace.position.copy(mid);
                    brace.lookAt(end);
                    brace.rotateX(Math.PI / 2);
                    
                    group.add(brace);
                }
            }
            
            // Platform at top
            const platformGeom = new THREE.CylinderGeometry(8, 8, 2, 6);
            const platformMat = new THREE.MeshStandardMaterial({
                color: 0x666666,
                metalness: 0.7,
                roughness: 0.3
            });
            const platform = new THREE.Mesh(platformGeom, platformMat);
            platform.position.set(35, towerBaseY + towerHeight - 5, -30);
            platform.castShadow = true;
            group.add(platform);
            addLabel(platform, 'Cell Tower', '5G/LTE transmission', {y: 8});
            
            // Modern antenna panels (multiple sectors)
            const antennaLevels = [towerBaseY + towerHeight - 15, towerBaseY + towerHeight - 25, towerBaseY + towerHeight - 35];
            
            antennaLevels.forEach((height, levelIndex) => {
                for (let i = 0; i < 3; i++) {
                    const angle = (i / 3) * Math.PI * 2;
                    
                    // Antenna panel array
                    const panelGroup = new THREE.Group();
                    
                    // Main panel (realistic 5G antenna)
                    const panelGeom = new THREE.BoxGeometry(3, 12, 0.8);
                    const panelMat = new THREE.MeshStandardMaterial({
                        color: 0xe0e0e0,
                        metalness: 0.6,
                        roughness: 0.3
                    });
                    const panel = new THREE.Mesh(panelGeom, panelMat);
                    panel.castShadow = true;
                    panelGroup.add(panel);
                    
                    // Antenna elements (vertical strips)
                    for (let strip = 0; strip < 8; strip++) {
                        const stripGeom = new THREE.BoxGeometry(2, 1.2, 0.3);
                        const stripMat = new THREE.MeshStandardMaterial({
                            color: 0x333333,
                            metalness: 0.9,
                            roughness: 0.2
                        });
                        const stripMesh = new THREE.Mesh(stripGeom, stripMat);
                        stripMesh.position.set(0, strip * 1.4 - 4.9, 0.55);
                        panelGroup.add(stripMesh);
                    }
                    
                    // Mounting bracket
                    const bracketGeom = new THREE.BoxGeometry(0.6, 14, 1.5);
                    const bracketMat = new THREE.MeshStandardMaterial({
                        color: 0x555555,
                        metalness: 0.8,
                        roughness: 0.4
                    });
                    const bracket = new THREE.Mesh(bracketGeom, bracketMat);
                    bracket.position.z = -1.2;
                    panelGroup.add(bracket);
                    
                    // Position panel
                    panelGroup.position.set(
                        35 + Math.cos(angle) * 9,
                        height,
                        -30 + Math.sin(angle) * 9
                    );
                    panelGroup.rotation.y = angle + Math.PI / 2;
                    
                    group.add(panelGroup);
                }
            });
            
            // Warning lights
            for (let i = 0; i < 3; i++) {
                const lightGeom = new THREE.SphereGeometry(0.5, 16, 16);
                const lightMat = new THREE.MeshBasicMaterial({
                    color: 0xff0000,
                    emissive: 0xff0000,
                    emissiveIntensity: 1
                });
                const light = new THREE.Mesh(lightGeom, lightMat);
                light.position.set(35, towerBaseY + towerHeight - 2 - i * 25, -30);
                group.add(light);
            }
            
            // === REALISTIC WiFi ROUTER (Modern gaming router design) ===
            const routerGroup = new THREE.Group();
            routerGroup.position.set(-60, -15, -20);
            group.add(routerGroup);
            
            // Router main body (angular gaming style)
            const routerBodyGeom = new THREE.BoxGeometry(12, 3, 10);
            const routerBodyMat = new THREE.MeshPhysicalMaterial({
                color: 0x1a1a1a,
                roughness: 0.3,
                metalness: 0.7,
                clearcoat: 0.5
            });
            const routerBody = new THREE.Mesh(routerBodyGeom, routerBodyMat);
            routerBody.castShadow = true;
            routerGroup.add(routerBody);
            
            // Top panel with vents
            const topPanelGeom = new THREE.BoxGeometry(11.5, 0.3, 9.5);
            const topPanelMat = new THREE.MeshPhysicalMaterial({
                color: 0x2d3748,
                roughness: 0.25,
                metalness: 0.8
            });
            const topPanel = new THREE.Mesh(topPanelGeom, topPanelMat);
            topPanel.position.y = 1.65;
            routerGroup.add(topPanel);
            
            // Vent slots (cooling)
            for (let i = 0; i < 8; i++) {
                const ventGeom = new THREE.BoxGeometry(1, 0.2, 0.3);
                const ventMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
                const vent = new THREE.Mesh(ventGeom, ventMat);
                vent.position.set(-4 + i * 1, 1.75, 0);
                routerGroup.add(vent);
            }
            
            // LED status lights (front)
            const ledColors = [0x00ff00, 0x00ff00, 0x3b82f6, 0x3b82f6, 0xfbbf24];
            ledColors.forEach((color, idx) => {
                const ledGeom = new THREE.CircleGeometry(0.3, 16);
                const ledMat = new THREE.MeshBasicMaterial({
                    color: color,
                    emissive: color,
                    emissiveIntensity: 0.8
                });
                const led = new THREE.Mesh(ledGeom, ledMat);
                led.position.set(-4 + idx * 2, 0.5, 5.1);
                led.rotation.y = Math.PI;
                routerGroup.add(led);
                anims.push({ type: 'routerLED', obj: led, idx });
            });
            
            // Logo/brand area (front center)
            const logoGeom = new THREE.BoxGeometry(3, 1, 0.1);
            const logoMat = new THREE.MeshPhysicalMaterial({
                color: 0x3b82f6,
                emissive: 0x3b82f6,
                emissiveIntensity: 0.4,
                roughness: 0.2,
                metalness: 0.9
            });
            const logo = new THREE.Mesh(logoGeom, logoMat);
            logo.position.set(0, -0.3, 5.05);
            routerGroup.add(logo);
            
            // === REALISTIC ANTENNAS (4 external antennas) ===
            const antennaPositions = [
                { x: -5, z: -4, angle: -0.3 },
                { x: -2, z: -4.5, angle: -0.2 },
                { x: 2, z: -4.5, angle: 0.2 },
                { x: 5, z: -4, angle: 0.3 }
            ];
            
            antennaPositions.forEach((pos, idx) => {
                // Antenna base (articulated joint)
                const baseGeom = new THREE.CylinderGeometry(0.6, 0.7, 1, 16);
                const baseMat = new THREE.MeshPhysicalMaterial({
                    color: 0x1a1a1a,
                    roughness: 0.3,
                    metalness: 0.8
                });
                const base = new THREE.Mesh(baseGeom, baseMat);
                base.position.set(pos.x, -1, pos.z);
                routerGroup.add(base);
                
                // Antenna rod (main element)
                const antennaGeom = new THREE.CylinderGeometry(0.35, 0.35, 9, 12);
                const antennaMat = new THREE.MeshPhysicalMaterial({
                    color: 0x374151,
                    roughness: 0.25,
                    metalness: 0.85,
                    clearcoat: 0.6
                });
                const antenna = new THREE.Mesh(antennaGeom, antennaMat);
                antenna.position.set(pos.x, 3, pos.z);
                antenna.rotation.z = pos.angle;
                antenna.castShadow = true;
                routerGroup.add(antenna);
                
                // Antenna tip (active element with LED)
                const tipGeom = new THREE.CylinderGeometry(0.25, 0.35, 1.5, 12);
                const tipMat = new THREE.MeshStandardMaterial({
                    color: 0x22c55e,
                    emissive: 0x22c55e,
                    emissiveIntensity: 0.5,
                    roughness: 0.2,
                    metalness: 0.9
                });
                const tip = new THREE.Mesh(tipGeom, tipMat);
                const tipHeight = 3 + Math.cos(pos.angle) * 4.5;
                const tipOffset = Math.sin(pos.angle) * 4.5;
                tip.position.set(pos.x + tipOffset, tipHeight + 0.75, pos.z);
                tip.rotation.z = pos.angle;
                routerGroup.add(tip);
                anims.push({ type: 'antenna', obj: tip, i: idx });
            });
            
            // Ethernet ports (back)
            for (let i = 0; i < 4; i++) {
                const portGeom = new THREE.BoxGeometry(1.2, 0.8, 0.3);
                const portMat = new THREE.MeshPhysicalMaterial({
                    color: 0xfbbf24,
                    roughness: 0.3,
                    metalness: 0.9
                });
                const port = new THREE.Mesh(portGeom, portMat);
                port.position.set(-3 + i * 2, 0, -5.15);
                routerGroup.add(port);
            }
            
            // Power button (top)
            const powerButtonGeom = new THREE.CylinderGeometry(0.4, 0.4, 0.2, 16);
            const powerButtonMat = new THREE.MeshBasicMaterial({
                color: 0xff0000,
                emissive: 0xff0000,
                emissiveIntensity: 0.6
            });
            const powerButton = new THREE.Mesh(powerButtonGeom, powerButtonMat);
            powerButton.position.set(4.5, 1.8, 3);
            routerGroup.add(powerButton);
            
            addLabel(routerGroup, 'WiFi 6E Router', '2.4/5/6 GHz tri-band', {y: 10});
            
            // Realistic smartphone - iPhone-style modern design with real iPhone image
            const phoneGroup = new THREE.Group();
            phoneGroup.scale.set(1.5, 1.5, 1.5);
            phoneGroup.position.set(0, 0, 0);
            group.add(phoneGroup);
            
            // Main body with dark blue iPhone material (thinner, semi-transparent)
            const phoneBodyGeom = new THREE.BoxGeometry(7.5, 0.5, 15);
            const phoneBodyMat = new THREE.MeshPhysicalMaterial({
                color: 0x2563eb,
                emissive: 0x1e40af,
                emissiveIntensity: 0.15,
                metalness: 0.7,
                roughness: 0.15,
                clearcoat: 1.0,
                clearcoatRoughness: 0.05,
                transparent: true,
                opacity: 0.85,
                transmission: 0.15
            });
            const phoneBody = new THREE.Mesh(phoneBodyGeom, phoneBodyMat);
            phoneBody.castShadow = true;
            phoneBody.receiveShadow = true;
            phoneGroup.add(phoneBody);
            anims.push({ type: 'phone', obj: phoneGroup });
            
            // Very dark LCD screen on front surface
            const screenGeom = new THREE.BoxGeometry(7.2, 0.02, 14.6);
            const screenMat = new THREE.MeshStandardMaterial({
                color: 0x020408,
                emissive: 0x0a1220,
                emissiveIntensity: 0.15,
                metalness: 0.05,
                roughness: 0.7
            });
            const screen = new THREE.Mesh(screenGeom, screenMat);
            screen.position.set(0, 0.26, 0);
            phoneBody.add(screen);
            
            // Small black notch at top
            const notchGeom = new THREE.BoxGeometry(2, 0.03, 0.4);
            const notchMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
            const notch = new THREE.Mesh(notchGeom, notchMat);
            notch.position.set(0, 0.27, 6.9);
            phoneBody.add(notch);
            
            // Camera module (back, top-left)
            const cameraModuleGeom = new THREE.BoxGeometry(2.2, 0.3, 2.2);
            const cameraModuleMat = new THREE.MeshStandardMaterial({
                color: 0x1e40af,
                metalness: 0.7,
                roughness: 0.3
            });
            const cameraModule = new THREE.Mesh(cameraModuleGeom, cameraModuleMat);
            cameraModule.position.set(-2.5, -0.28, -6);
            phoneBody.add(cameraModule);
            
            // Camera lenses (3 lenses)
            const lensPositions = [
                [-0.6, 0.6], [0.6, 0.6], [-0.6, -0.6]
            ];
            
            lensPositions.forEach(pos => {
                // Lens ring
                const lensRingGeom = new THREE.CylinderGeometry(0.5, 0.5, 0.15, 32);
                const lensRingMat = new THREE.MeshStandardMaterial({
                    color: 0x333333,
                    metalness: 0.9,
                    roughness: 0.2
                });
                const lensRing = new THREE.Mesh(lensRingGeom, lensRingMat);
                lensRing.position.set(pos[0], 0.2, pos[1]);
                cameraModule.add(lensRing);
                
                // Lens glass
                const lensGeom = new THREE.CylinderGeometry(0.4, 0.4, 0.05, 32);
                const lensMat = new THREE.MeshPhysicalMaterial({
                    color: 0x0a0a1a,
                    metalness: 0.1,
                    roughness: 0.05,
                    transmission: 0.8,
                    thickness: 0.5
                });
                const lens = new THREE.Mesh(lensGeom, lensMat);
                lens.position.set(pos[0], 0.25, pos[1]);
                cameraModule.add(lens);
            });
            
            // Flash
            const flashGeom = new THREE.CylinderGeometry(0.3, 0.3, 0.1, 16);
            const flashMat = new THREE.MeshBasicMaterial({
                color: 0xffffee,
                emissive: 0xffffaa,
                emissiveIntensity: 0.5
            });
            const flash = new THREE.Mesh(flashGeom, flashMat);
            flash.position.set(0.6, 0.2, -0.6);
            cameraModule.add(flash);
            
            // Side buttons (volume and power) - metallic
            // Volume up button
            const volUpGeom = new THREE.BoxGeometry(0.2, 0.15, 1.5);
            const buttonMat = new THREE.MeshStandardMaterial({
                color: 0xc0c0c0,
                metalness: 1.0,
                roughness: 0.2
            });
            const volUp = new THREE.Mesh(volUpGeom, buttonMat);
            volUp.position.set(-3.85, 0, 2);
            phoneBody.add(volUp);
            
            // Volume down button
            const volDown = new THREE.Mesh(volUpGeom, buttonMat);
            volDown.position.set(-3.85, 0, 0);
            phoneBody.add(volDown);
            
            // Silent/ring switch
            const silentSwitchGeom = new THREE.BoxGeometry(0.2, 0.1, 0.8);
            const silentSwitch = new THREE.Mesh(silentSwitchGeom, buttonMat);
            silentSwitch.position.set(-3.85, 0, 4);
            phoneBody.add(silentSwitch);
            
            // Power button (right side)
            const powerBtnGeom = new THREE.BoxGeometry(0.2, 0.15, 2);
            const powerBtn = new THREE.Mesh(powerBtnGeom, buttonMat);
            powerBtn.position.set(3.85, 0, 2);
            phoneBody.add(powerBtn);
            
            addLabel(phoneGroup, 'Smartphone', '100+ RF filters inside', {y: -12});
            
            // Signal waves from tower (sinusoidal)
            for (let i = 0; i < 12; i++) {
                const waveGeom = new THREE.TorusGeometry(3 + i * 3, 0.15, 8, 32, Math.PI);
                const wave = new THREE.Mesh(
                    waveGeom,
                    new THREE.MeshBasicMaterial({
                        color: 0xef4444,
                        transparent: true,
                        opacity: 0.6 - i * 0.04
                    })
                );
                wave.position.set(35, 20, -30);
                wave.rotation.y = -Math.PI / 4;
                wave.rotation.z = Math.PI / 2;
                group.add(wave);
                anims.push({ type: 'towerWave', obj: wave, i });
            }
            
            // Signal waves from router
            for (let i = 0; i < 8; i++) {
                const waveGeom = new THREE.TorusGeometry(2 + i * 2.5, 0.12, 8, 32, Math.PI);
                const wave = new THREE.Mesh(
                    waveGeom,
                    new THREE.MeshBasicMaterial({
                        color: 0x22c55e,
                        transparent: true,
                        opacity: 0.6 - i * 0.06
                    })
                );
                wave.position.set(-60, -10, -20);
                wave.rotation.y = Math.PI / 3;
                wave.rotation.z = Math.PI / 2;
                group.add(wave);
                anims.push({ type: 'routerWave', obj: wave, i });
            }
            
            // Signal particles traveling to phone
            for (let i = 0; i < 15; i++) {
                const particle = new THREE.Mesh(
                    new THREE.SphereGeometry(0.8, 12, 12),
                    new THREE.MeshStandardMaterial({
                        color: i < 8 ? 0xef4444 : 0x22c55e,
                        emissive: i < 8 ? 0xef4444 : 0x22c55e,
                        emissiveIntensity: 0.5
                    })
                );
                group.add(particle);
                anims.push({
                    type: 'signalParticle',
                    obj: particle,
                    source: i < 8 ? [35, 20, -30] : [-60, -10, -20],
                    target: [0, 0, 0],
                    offset: i * 0.08
                });
            }
        }
        
        function buildSmartphoneRF() {
            const group = currentGroup;
            
            // === DETAILED SMARTPHONE WITH INTERNAL RF COMPONENTS ===
            const phoneGroup = new THREE.Group();
            phoneGroup.scale.set(4, 4, 4);
            phoneGroup.position.set(0, 0, 0);
            
            // Phone body with dark blue iPhone material (thinner, semi-transparent)
            const phoneBodyGeom = new THREE.BoxGeometry(7.5, 0.5, 15);
            const phoneBodyMat = new THREE.MeshPhysicalMaterial({
                color: 0x2563eb,
                emissive: 0x1e40af,
                emissiveIntensity: 0.15,
                metalness: 0.7,
                roughness: 0.15,
                clearcoat: 1.0,
                clearcoatRoughness: 0.05,
                transparent: true,
                opacity: 0.85,
                transmission: 0.15
            });
            const phoneBody = new THREE.Mesh(phoneBodyGeom, phoneBodyMat);
            phoneBody.castShadow = true;
            phoneBody.receiveShadow = true;
            phoneGroup.add(phoneBody);
            
            // Very dark LCD screen on front surface
            const screenGeom = new THREE.BoxGeometry(7.1, 0.02, 14.2);
            const screenMat = new THREE.MeshStandardMaterial({
                color: 0x020408,
                emissive: 0x0a1220,
                emissiveIntensity: 0.2,
                metalness: 0.05,
                roughness: 0.7
            });
            const screen = new THREE.Mesh(screenGeom, screenMat);
            screen.position.set(0, 0.26, 0);
            phoneBody.add(screen);
            
            // Small black notch at top
            const notchGeom = new THREE.BoxGeometry(2, 0.03, 0.5);
            const notchMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
            const notch = new THREE.Mesh(notchGeom, notchMat);
            notch.position.set(0, 0.27, 6.8);
            phoneBody.add(notch);
            
            // Camera module (triple camera)
            const cameraModuleGeom = new THREE.BoxGeometry(2.5, 0.15, 3);
            const cameraModuleMat = new THREE.MeshStandardMaterial({
                color: 0x1e40af,
                metalness: 0.9,
                roughness: 0.3
            });
            const cameraModule = new THREE.Mesh(cameraModuleGeom, cameraModuleMat);
            cameraModule.position.set(-2, -0.33, 5);
            phoneBody.add(cameraModule);
            
            // Three camera lenses
            const lensPositions = [[0, 0.8], [-0.8, -0.8], [0.8, -0.8]];
            lensPositions.forEach(pos => {
                const lensRingGeom = new THREE.CylinderGeometry(0.5, 0.5, 0.1, 32);
                const lensRingMat = new THREE.MeshStandardMaterial({
                    color: 0x6b7280,
                    metalness: 1.0,
                    roughness: 0.2
                });
                const lensRing = new THREE.Mesh(lensRingGeom, lensRingMat);
                lensRing.rotation.x = Math.PI / 2;
                lensRing.position.set(pos[0], 0, pos[1]);
                cameraModule.add(lensRing);
                
                const lensGeom = new THREE.CylinderGeometry(0.4, 0.4, 0.05, 32);
                const lensMat = new THREE.MeshPhysicalMaterial({
                    color: 0x0a0a1a,
                    metalness: 0.1,
                    roughness: 0.05,
                    transmission: 0.8,
                    thickness: 0.5
                });
                const lens = new THREE.Mesh(lensGeom, lensMat);
                lens.rotation.x = Math.PI / 2;
                lens.position.set(pos[0], 0.08, pos[1]);
                cameraModule.add(lens);
            });
            
            // Side buttons (volume and power) - metallic iPhone buttons
            const sideButtonMat = new THREE.MeshStandardMaterial({
                color: 0xd0d0d0,
                metalness: 1.0,
                roughness: 0.15
            });
            
            // Volume up button (left side)
            const volUpGeom = new THREE.BoxGeometry(0.2, 0.15, 1.5);
            const volUp = new THREE.Mesh(volUpGeom, sideButtonMat);
            volUp.position.set(-3.85, 0, 2);
            phoneBody.add(volUp);
            
            // Volume down button (left side)
            const volDown = new THREE.Mesh(volUpGeom, sideButtonMat);
            volDown.position.set(-3.85, 0, 0);
            phoneBody.add(volDown);
            
            // Silent/ring switch (left side, top)
            const silentSwitchGeom = new THREE.BoxGeometry(0.2, 0.1, 0.8);
            const silentSwitch = new THREE.Mesh(silentSwitchGeom, sideButtonMat);
            silentSwitch.position.set(-3.85, 0, 4);
            phoneBody.add(silentSwitch);
            
            // Power button (right side)
            const powerBtnGeom = new THREE.BoxGeometry(0.2, 0.15, 2);
            const powerBtn = new THREE.Mesh(powerBtnGeom, sideButtonMat);
            powerBtn.position.set(3.85, 0, 2);
            phoneBody.add(powerBtn);
            
            // SIM card tray (right side, bottom)
            const simTrayGeom = new THREE.BoxGeometry(0.15, 0.08, 1.2);
            const simTray = new THREE.Mesh(simTrayGeom, sideButtonMat);
            simTray.position.set(3.85, 0, -4);
            phoneBody.add(simTray);
            
            // === INTERNAL COMPONENTS (visible through transparency) ===
            const internalGroup = new THREE.Group();
            internalGroup.position.y = 0;
            
            // PCB Board (green circuit board)
            const pcbGeom = new THREE.BoxGeometry(6.5, 0.1, 13);
            const pcbMat = new THREE.MeshStandardMaterial({
                color: 0x047857,
                roughness: 0.6,
                metalness: 0.3
            });
            const pcb = new THREE.Mesh(pcbGeom, pcbMat);
            internalGroup.add(pcb);
            
            // Main processor chip
            const processorGeom = new THREE.BoxGeometry(1.5, 0.15, 1.5);
            const processorMat = new THREE.MeshStandardMaterial({
                color: 0x1f2937,
                metalness: 0.9,
                roughness: 0.2
            });
            const processor = new THREE.Mesh(processorGeom, processorMat);
            processor.position.set(0, 0.13, 0);
            internalGroup.add(processor);
            
            // RF chip
            const rfChipGeom = new THREE.BoxGeometry(1, 0.12, 1);
            const rfChipMat = new THREE.MeshStandardMaterial({
                color: 0x374151,
                metalness: 0.8,
                roughness: 0.3
            });
            const rfChip = new THREE.Mesh(rfChipGeom, rfChipMat);
            rfChip.position.set(-2, 0.11, -3);
            internalGroup.add(rfChip);
            anims.push({ type: 'rfChipGlow', obj: rfChip });
            
            // SAW Filters (6 miniature gold filters)
            const sawPositions = [
                [-2.5, -4], [-1.5, -4], [-0.5, -4],
                [-2.5, -5], [-1.5, -5], [-0.5, -5]
            ];
            sawPositions.forEach((pos, idx) => {
                const sawGeom = new THREE.BoxGeometry(0.6, 0.18, 0.5);
                const sawMat = new THREE.MeshStandardMaterial({
                    color: 0xf59e0b,
                    metalness: 0.9,
                    roughness: 0.3,
                    emissive: 0xf59e0b,
                    emissiveIntensity: 0.1
                });
                const sawFilter = new THREE.Mesh(sawGeom, sawMat);
                sawFilter.position.set(pos[0], 0.14, pos[1]);
                internalGroup.add(sawFilter);
                anims.push({ type: 'sawFilterPulse', obj: sawFilter, idx });
            });
            
            // Battery (large rectangular component)
            const batteryGeom = new THREE.BoxGeometry(5, 0.2, 8);
            const batteryMat = new THREE.MeshStandardMaterial({
                color: 0x6b7280,
                metalness: 0.6,
                roughness: 0.4
            });
            const battery = new THREE.Mesh(batteryGeom, batteryMat);
            battery.position.set(0, 0.05, 3);
            internalGroup.add(battery);
            
            // Antenna traces (gold lines on PCB)
            for (let i = 0; i < 8; i++) {
                const traceGeom = new THREE.BoxGeometry(0.05, 0.02, 2 + i * 0.3);
                const traceMat = new THREE.MeshStandardMaterial({
                    color: 0xf59e0b,
                    metalness: 1.0,
                    roughness: 0.2,
                    emissive: 0xf59e0b,
                    emissiveIntensity: 0.05
                });
                const trace = new THREE.Mesh(traceGeom, traceMat);
                trace.position.set(-3 + i * 0.8, 0.11, -5 + i * 0.4);
                internalGroup.add(trace);
            }
            
            phoneBody.add(internalGroup);
            
            // === RF SIGNAL PARTICLES ===
            for (let i = 0; i < 80; i++) {
                const particleGeom = new THREE.SphereGeometry(0.12, 8, 8);
                const particleMat = new THREE.MeshStandardMaterial({
                    color: i < 40 ? 0xef4444 : 0x0ea5e9,
                    emissive: i < 40 ? 0xef4444 : 0x0ea5e9,
                    emissiveIntensity: 0.8,
                    transparent: true,
                    opacity: 0.9
                });
                const particle = new THREE.Mesh(particleGeom, particleMat);
                phoneGroup.add(particle);
                
                anims.push({
                    type: 'rfSignalParticle',
                    obj: particle,
                    phoneGroup: phoneGroup,
                    startAngle: (i / 80) * Math.PI * 2,
                    radius: 10 + Math.random() * 5,
                    speed: 0.5 + Math.random() * 0.5,
                    height: -3 + Math.random() * 6
                });
            }
            
            // === SAW PROPAGATION WAVES (rings emanating from phone) ===
            for (let i = 0; i < 12; i++) {
                const waveGeom = new THREE.TorusGeometry(5 + i * 2, 0.15, 8, 32);
                const waveMat = new THREE.MeshBasicMaterial({
                    color: 0x10b981,
                    transparent: true,
                    opacity: 0.6 - i * 0.04
                });
                const wave = new THREE.Mesh(waveGeom, waveMat);
                phoneGroup.add(wave);
                anims.push({ type: 'phoneRFWave', obj: wave, idx: i });
            }
            
            group.add(phoneGroup);
            
            addLabel(group, 'Smartphone RF Frontend', '6× SAW Filters + Phononic Crystals', {y: -18});
        }
        
        // Helper function for SAW IDT construction
        function buildIDTForSAW(xPos, type, group) {
            const idtGroup = new THREE.Group();
            idtGroup.position.x = xPos;
            
            // IDT finger electrodes
            const fingerCount = 25;
            const fingerSpacing = 0.6;
            const fingerWidth = 0.25;
            const fingerLength = 12;
            
            for (let i = 0; i < fingerCount; i++) {
                const fingerGeo = new THREE.BoxGeometry(fingerWidth, 0.15, fingerLength);
                const fingerMat = new THREE.MeshStandardMaterial({
                    color: 0xf59e0b,
                    roughness: 0.3,
                    metalness: 0.9,
                    emissive: 0xf59e0b,
                    emissiveIntensity: 0.1
                });
                const finger = new THREE.Mesh(fingerGeo, fingerMat);
                finger.position.set(
                    (i - fingerCount/2) * fingerSpacing,
                    1.08,
                    i % 2 === 0 ? -3 : 3
                );
                finger.castShadow = true;
                idtGroup.add(finger);
                anims.push({ type: 'idtFingerRF', obj: finger, i, xPos });
            }
            
            // Bus bars (connect alternate fingers)
            const busGeo = new THREE.BoxGeometry(fingerCount * fingerSpacing, 0.15, 1.5);
            const busMat = new THREE.MeshStandardMaterial({
                color: 0xf59e0b,
                roughness: 0.3,
                metalness: 0.9
            });
            
            const topBus = new THREE.Mesh(busGeo, busMat);
            topBus.position.set(0, 1.08, -10);
            idtGroup.add(topBus);
            
            const bottomBus = new THREE.Mesh(busGeo, busMat);
            bottomBus.position.set(0, 1.08, 10);
            idtGroup.add(bottomBus);
            
            // Connection pads
            const padGeo = new THREE.BoxGeometry(3, 0.2, 4);
            const topPad = new THREE.Mesh(padGeo, busMat);
            topPad.position.set(0, 1.1, -13);
            idtGroup.add(topPad);
            
            const bottomPad = new THREE.Mesh(padGeo, busMat);
            bottomPad.position.set(0, 1.1, 13);
            idtGroup.add(bottomPad);
            
            group.add(idtGroup);
        }
        
        // Helper function for phononic crystal
        function buildPhononicCrystalForSAW(group) {
            const pcGroup = new THREE.Group();
            
            // Phononic crystal pillars (periodic structure for filtering)
            const rows = 8;
            const cols = 12;
            const spacing = 1.8;
            
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    const pillarGeo = new THREE.CylinderGeometry(0.4, 0.4, 1.5, 16);
                    const pillarMat = new THREE.MeshStandardMaterial({
                        color: 0x0ea5e9,
                        roughness: 0.3,
                        metalness: 0.7,
                        emissive: 0x0ea5e9,
                        emissiveIntensity: 0.2
                    });
                    const pillar = new THREE.Mesh(pillarGeo, pillarMat);
                    pillar.position.set(
                        (j - cols/2 + 0.5) * spacing,
                        1.75,
                        (i - rows/2 + 0.5) * spacing
                    );
                    pillar.castShadow = true;
                    pcGroup.add(pillar);
                    anims.push({ type: 'pcPillarRF', obj: pillar, i, j });
                }
            }
            
            // Topological interface line (where edge states form)
            const interfaceGeo = new THREE.BoxGeometry(cols * spacing, 0.3, 0.5);
            const interfaceMat = new THREE.MeshStandardMaterial({
                color: 0x10b981,
                emissive: 0x10b981,
                emissiveIntensity: 0.5
            });
            const interface1 = new THREE.Mesh(interfaceGeo, interfaceMat);
            interface1.position.set(0, 1.15, 0);
            pcGroup.add(interface1);
            anims.push({ type: 'topoInterfaceRF', obj: interface1 });
            
            group.add(pcGroup);
        }
        
        // Helper function for reflectors
        function buildReflectorsForSAW(xPos, group) {
            const refGroup = new THREE.Group();
            refGroup.position.x = xPos;
            
            // Reflector grating strips
            const stripCount = 15;
            const stripSpacing = 0.5;
            
            for (let i = 0; i < stripCount; i++) {
                const stripGeo = new THREE.BoxGeometry(0.2, 0.1, 10);
                const stripMat = new THREE.MeshStandardMaterial({
                    color: 0x6b7280,
                    roughness: 0.4,
                    metalness: 0.8
                });
                const strip = new THREE.Mesh(stripGeo, stripMat);
                strip.position.set((i - stripCount/2) * stripSpacing, 1.05, 0);
                refGroup.add(strip);
            }
            
            group.add(refGroup);
        }
        
        function buildSAWFilterDevice() {
            const group = currentGroup;
            
            // Container for zoomed view
            const sawGroup = new THREE.Group();
            sawGroup.scale.set(1.5, 1.5, 1.5);
            
            // === COMPLETE SAW RF FILTER DEVICE ===
            // === PIEZOELECTRIC SUBSTRATE (LiNbO3) ===
            const substrateGeo = new THREE.BoxGeometry(80, 2, 35);
            const substrateMat = new THREE.MeshStandardMaterial({
                color: 0x1e3a5f,
                roughness: 0.4,
                metalness: 0.1,
                transparent: true,
                opacity: 0.9
            });
            const substrate = new THREE.Mesh(substrateGeo, substrateMat);
            substrate.receiveShadow = true;
            substrate.position.y = 0;
            sawGroup.add(substrate);
            
            // Crystal structure pattern on substrate
            for (let i = 0; i < 200; i++) {
                const crystalGeo = new THREE.BoxGeometry(0.3, 0.1, 0.3);
                const crystalMat = new THREE.MeshStandardMaterial({
                    color: 0x2563eb,
                    emissive: 0x2563eb,
                    emissiveIntensity: 0.1
                });
                const crystal = new THREE.Mesh(crystalGeo, crystalMat);
                crystal.position.set(
                    (Math.random() - 0.5) * 75,
                    1.05,
                    (Math.random() - 0.5) * 30
                );
                sawGroup.add(crystal);
            }
            
            // === INPUT IDT (Interdigital Transducer) ===
            buildIDTForSAWFilter(-28, 'input', sawGroup);
            
            // === OUTPUT IDT ===
            buildIDTForSAWFilter(28, 'output', sawGroup);
            
            // === PHONONIC CRYSTAL REGION (between IDTs) ===
            buildPhononicCrystalForSAWFilter(sawGroup);
            
            // === REFLECTOR GRATINGS ===
            buildReflectorsForSAWFilter(-38, sawGroup);
            buildReflectorsForSAWFilter(38, sawGroup);
            
            // === BOND PADS ===
            const padPositions = [
                { x: -35, z: -14, label: 'IN+' },
                { x: -35, z: 14, label: 'IN-' },
                { x: 35, z: -14, label: 'OUT+' },
                { x: 35, z: 14, label: 'OUT-' }
            ];
            
            padPositions.forEach(pos => {
                const padGeo = new THREE.BoxGeometry(4, 0.3, 4);
                const padMat = new THREE.MeshStandardMaterial({
                    color: 0xf59e0b,
                    roughness: 0.3,
                    metalness: 0.9
                });
                const pad = new THREE.Mesh(padGeo, padMat);
                pad.position.set(pos.x, 1.15, pos.z);
                pad.castShadow = true;
                sawGroup.add(pad);
            });
            
            // === SAW WAVE VISUALIZATION ===
            for (let i = 0; i < 60; i++) {
                const waveGeo = new THREE.SphereGeometry(0.15, 6, 6);
                const waveMat = new THREE.MeshStandardMaterial({
                    color: 0x10b981,
                    emissive: 0x10b981,
                    emissiveIntensity: 0.8,
                    transparent: true,
                    opacity: 0.8
                });
                const wave = new THREE.Mesh(waveGeo, waveMat);
                sawGroup.add(wave);
                anims.push({
                    type: 'sawWaveFilter',
                    obj: wave,
                    progress: i / 60,
                    lane: i % 5
                });
            }
            
            group.add(sawGroup);
            addLabel(group, 'SAW RF Filter Device', 'Piezoelectric + Phononic Crystal Filtering', {y: -25});
        }
        
        function buildSAWOperation() {
            const group = currentGroup;
            
            // Container for close-up operation view
            const sawGroup = new THREE.Group();
            sawGroup.scale.set(2.0, 2.0, 2.0);
            sawGroup.rotation.y = Math.PI / 8;
            
            // === PIEZOELECTRIC SUBSTRATE ===
            const substrateGeo = new THREE.BoxGeometry(80, 2, 35);
            const substrateMat = new THREE.MeshStandardMaterial({
                color: 0x1e3a5f,
                roughness: 0.4,
                metalness: 0.1,
                transparent: true,
                opacity: 0.9
            });
            const substrate = new THREE.Mesh(substrateGeo, substrateMat);
            substrate.receiveShadow = true;
            sawGroup.add(substrate);
            
            // Crystal structure
            for (let i = 0; i < 200; i++) {
                const crystalGeo = new THREE.BoxGeometry(0.3, 0.1, 0.3);
                const crystalMat = new THREE.MeshStandardMaterial({
                    color: 0x2563eb,
                    emissive: 0x2563eb,
                    emissiveIntensity: 0.1
                });
                const crystal = new THREE.Mesh(crystalGeo, crystalMat);
                crystal.position.set(
                    (Math.random() - 0.5) * 75,
                    1.05,
                    (Math.random() - 0.5) * 30
                );
                sawGroup.add(crystal);
            }
            
            // IDTs
            buildIDTForSAWOperation(-28, 'input', sawGroup);
            buildIDTForSAWOperation(28, 'output', sawGroup);
            
            // Phononic Crystal
            buildPhononicCrystalForSAWOperation(sawGroup);
            
            // Reflectors
            buildReflectorsForSAWOperation(-38, sawGroup);
            buildReflectorsForSAWOperation(38, sawGroup);
            
            // Bond Pads
            const padPositions = [
                { x: -35, z: -14 }, { x: -35, z: 14 },
                { x: 35, z: -14 }, { x: 35, z: 14 }
            ];
            padPositions.forEach(pos => {
                const padGeo = new THREE.BoxGeometry(4, 0.3, 4);
                const padMat = new THREE.MeshStandardMaterial({
                    color: 0xf59e0b,
                    roughness: 0.3,
                    metalness: 0.9
                });
                const pad = new THREE.Mesh(padGeo, padMat);
                pad.position.set(pos.x, 1.15, pos.z);
                pad.castShadow = true;
                sawGroup.add(pad);
            });
            
            // SAW waves with enhanced visibility
            for (let i = 0; i < 80; i++) {
                const waveGeo = new THREE.SphereGeometry(0.2, 8, 8);
                const waveMat = new THREE.MeshStandardMaterial({
                    color: 0x10b981,
                    emissive: 0x10b981,
                    emissiveIntensity: 1.0,
                    transparent: true,
                    opacity: 0.9
                });
                const wave = new THREE.Mesh(waveGeo, waveMat);
                sawGroup.add(wave);
                anims.push({
                    type: 'sawWaveOperation',
                    obj: wave,
                    progress: i / 80,
                    lane: i % 6
                });
            }
            
            group.add(sawGroup);
            addLabel(group, 'SAW Filter Operation', 'RF → Acoustic → Phononic Filter → RF', {y: -30});
        }
        
        // Helper functions for SAW Operation view
        function buildIDTForSAWOperation(xPos, type, group) {
            const idtGroup = new THREE.Group();
            idtGroup.position.x = xPos;
            
            const fingerCount = 25;
            const fingerSpacing = 0.6;
            const fingerWidth = 0.25;
            const fingerLength = 12;
            
            for (let i = 0; i < fingerCount; i++) {
                const fingerGeo = new THREE.BoxGeometry(fingerWidth, 0.15, fingerLength);
                const fingerMat = new THREE.MeshStandardMaterial({
                    color: 0xf59e0b,
                    roughness: 0.3,
                    metalness: 0.9,
                    emissive: 0xf59e0b,
                    emissiveIntensity: 0.15
                });
                const finger = new THREE.Mesh(fingerGeo, fingerMat);
                finger.position.set(
                    (i - fingerCount/2) * fingerSpacing,
                    1.08,
                    i % 2 === 0 ? -3 : 3
                );
                finger.castShadow = true;
                idtGroup.add(finger);
                anims.push({ type: 'idtFingerOperation', obj: finger, i, xPos });
            }
            
            const busGeo = new THREE.BoxGeometry(fingerCount * fingerSpacing, 0.15, 1.5);
            const busMat = new THREE.MeshStandardMaterial({
                color: 0xf59e0b,
                roughness: 0.3,
                metalness: 0.9
            });
            
            const topBus = new THREE.Mesh(busGeo, busMat);
            topBus.position.set(0, 1.08, -10);
            idtGroup.add(topBus);
            
            const bottomBus = new THREE.Mesh(busGeo, busMat);
            bottomBus.position.set(0, 1.08, 10);
            idtGroup.add(bottomBus);
            
            const padGeo = new THREE.BoxGeometry(3, 0.2, 4);
            const topPad = new THREE.Mesh(padGeo, busMat);
            topPad.position.set(0, 1.1, -13);
            idtGroup.add(topPad);
            
            const bottomPad = new THREE.Mesh(padGeo, busMat);
            bottomPad.position.set(0, 1.1, 13);
            idtGroup.add(bottomPad);
            
            group.add(idtGroup);
        }
        
        function buildPhononicCrystalForSAWOperation(group) {
            const pcGroup = new THREE.Group();
            const rows = 8;
            const cols = 12;
            const spacing = 1.8;
            
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    const pillarGeo = new THREE.CylinderGeometry(0.4, 0.4, 1.5, 16);
                    const pillarMat = new THREE.MeshStandardMaterial({
                        color: 0x0ea5e9,
                        roughness: 0.3,
                        metalness: 0.7,
                        emissive: 0x0ea5e9,
                        emissiveIntensity: 0.3
                    });
                    const pillar = new THREE.Mesh(pillarGeo, pillarMat);
                    pillar.position.set(
                        (j - cols/2 + 0.5) * spacing,
                        1.75,
                        (i - rows/2 + 0.5) * spacing
                    );
                    pillar.castShadow = true;
                    pcGroup.add(pillar);
                    anims.push({ type: 'pcPillarOperation', obj: pillar, i, j });
                }
            }
            
            const interfaceGeo = new THREE.BoxGeometry(cols * spacing, 0.3, 0.5);
            const interfaceMat = new THREE.MeshStandardMaterial({
                color: 0x10b981,
                emissive: 0x10b981,
                emissiveIntensity: 0.6
            });
            const interface1 = new THREE.Mesh(interfaceGeo, interfaceMat);
            interface1.position.set(0, 1.15, 0);
            pcGroup.add(interface1);
            anims.push({ type: 'topoInterfaceOperation', obj: interface1 });
            
            group.add(pcGroup);
        }
        
        function buildReflectorsForSAWOperation(xPos, group) {
            const refGroup = new THREE.Group();
            refGroup.position.x = xPos;
            const stripCount = 15;
            const stripSpacing = 0.5;
            
            for (let i = 0; i < stripCount; i++) {
                const stripGeo = new THREE.BoxGeometry(0.2, 0.1, 10);
                const stripMat = new THREE.MeshStandardMaterial({
                    color: 0x6b7280,
                    roughness: 0.4,
                    metalness: 0.8
                });
                const strip = new THREE.Mesh(stripGeo, stripMat);
                strip.position.set((i - stripCount/2) * stripSpacing, 1.05, 0);
                refGroup.add(strip);
            }
            
            group.add(refGroup);
        }
        
        // Helper function for SAW Filter IDT construction
        function buildIDTForSAWFilter(xPos, type, group) {
            const idtGroup = new THREE.Group();
            idtGroup.position.x = xPos;
            
            // IDT finger electrodes
            const fingerCount = 25;
            const fingerSpacing = 0.6;
            const fingerWidth = 0.25;
            const fingerLength = 12;
            
            for (let i = 0; i < fingerCount; i++) {
                const fingerGeo = new THREE.BoxGeometry(fingerWidth, 0.15, fingerLength);
                const fingerMat = new THREE.MeshStandardMaterial({
                    color: 0xf59e0b,
                    roughness: 0.3,
                    metalness: 0.9,
                    emissive: 0xf59e0b,
                    emissiveIntensity: 0.1
                });
                const finger = new THREE.Mesh(fingerGeo, fingerMat);
                finger.position.set(
                    (i - fingerCount/2) * fingerSpacing,
                    1.08,
                    i % 2 === 0 ? -3 : 3
                );
                finger.castShadow = true;
                idtGroup.add(finger);
                anims.push({ type: 'idtFingerFilter', obj: finger, i, xPos });
            }
            
            // Bus bars (connect alternate fingers)
            const busGeo = new THREE.BoxGeometry(fingerCount * fingerSpacing, 0.15, 1.5);
            const busMat = new THREE.MeshStandardMaterial({
                color: 0xf59e0b,
                roughness: 0.3,
                metalness: 0.9
            });
            
            const topBus = new THREE.Mesh(busGeo, busMat);
            topBus.position.set(0, 1.08, -10);
            idtGroup.add(topBus);
            
            const bottomBus = new THREE.Mesh(busGeo, busMat);
            bottomBus.position.set(0, 1.08, 10);
            idtGroup.add(bottomBus);
            
            // Connection pads
            const padGeo = new THREE.BoxGeometry(3, 0.2, 4);
            const topPad = new THREE.Mesh(padGeo, busMat);
            topPad.position.set(0, 1.1, -13);
            idtGroup.add(topPad);
            
            const bottomPad = new THREE.Mesh(padGeo, busMat);
            bottomPad.position.set(0, 1.1, 13);
            idtGroup.add(bottomPad);
            
            group.add(idtGroup);
        }
        
        // Helper function for SAW Filter phononic crystal
        function buildPhononicCrystalForSAWFilter(group) {
            const pcGroup = new THREE.Group();
            
            // Phononic crystal pillars (periodic structure for filtering)
            const rows = 8;
            const cols = 12;
            const spacing = 1.8;
            
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    const pillarGeo = new THREE.CylinderGeometry(0.4, 0.4, 1.5, 16);
                    const pillarMat = new THREE.MeshStandardMaterial({
                        color: 0x0ea5e9,
                        roughness: 0.3,
                        metalness: 0.7,
                        emissive: 0x0ea5e9,
                        emissiveIntensity: 0.2
                    });
                    const pillar = new THREE.Mesh(pillarGeo, pillarMat);
                    pillar.position.set(
                        (j - cols/2 + 0.5) * spacing,
                        1.75,
                        (i - rows/2 + 0.5) * spacing
                    );
                    pillar.castShadow = true;
                    pcGroup.add(pillar);
                    anims.push({ type: 'pcPillarFilter', obj: pillar, i, j });
                }
            }
            
            // Topological interface line (where edge states form)
            const interfaceGeo = new THREE.BoxGeometry(cols * spacing, 0.3, 0.5);
            const interfaceMat = new THREE.MeshStandardMaterial({
                color: 0x10b981,
                emissive: 0x10b981,
                emissiveIntensity: 0.5
            });
            const interface1 = new THREE.Mesh(interfaceGeo, interfaceMat);
            interface1.position.set(0, 1.15, 0);
            pcGroup.add(interface1);
            anims.push({ type: 'topoInterfaceFilter', obj: interface1 });
            
            group.add(pcGroup);
        }
        
        // Helper function for SAW Filter reflectors
        function buildReflectorsForSAWFilter(xPos, group) {
            const refGroup = new THREE.Group();
            refGroup.position.x = xPos;
            
            // Reflector grating strips
            const stripCount = 15;
            const stripSpacing = 0.5;
            
            for (let i = 0; i < stripCount; i++) {
                const stripGeo = new THREE.BoxGeometry(0.2, 0.1, 10);
                const stripMat = new THREE.MeshStandardMaterial({
                    color: 0x6b7280,
                    roughness: 0.4,
                    metalness: 0.8
                });
                const strip = new THREE.Mesh(stripGeo, stripMat);
                strip.position.set((i - stripCount/2) * stripSpacing, 1.05, 0);
                refGroup.add(strip);
            }
            
            group.add(refGroup);
        }
        
        function buildSAWDevice() {
            const group = currentGroup;
            const phoneGroup = new THREE.Group();
            phoneGroup.scale.set(5, 5, 5);
            phoneGroup.position.set(0, 10, 0);
            group.add(phoneGroup);
            
            // Main body with rounded edges
            const phoneBodyGeom = new THREE.BoxGeometry(7.5, 0.8, 15);
            const phoneBodyMat = new THREE.MeshPhysicalMaterial({
                color: 0xf59e0b,
                emissive: 0xf59e0b,
                emissiveIntensity: 0.15,
                metalness: 0.8,
                roughness: 0.3,
                clearcoat: 0.5,
                clearcoatRoughness: 0.2
            });
            const phoneBody = new THREE.Mesh(phoneBodyGeom, phoneBodyMat);
            phoneBody.castShadow = true;
            phoneBody.receiveShadow = true;
            phoneGroup.add(phoneBody);
            
            // Aluminum frame (sides)
            const frameGeom = new THREE.BoxGeometry(7.6, 0.4, 15.1);
            const frameMat = new THREE.MeshStandardMaterial({
                color: 0xfbbf24,
                metalness: 0.9,
                roughness: 0.2
            });
            const frame = new THREE.Mesh(frameGeom, frameMat);
            frame.position.y = 0.2;
            phoneBody.add(frame);
            
            // Blue glowing screen horizontal to the phone plane
            const screenGeom = new THREE.BoxGeometry(7.1, 0.1, 14.2);
            const screenMat = new THREE.MeshBasicMaterial({
                color: 0x0066ff,
                emissive: 0x0066ff,
                emissiveIntensity: 0.5
            });
            const screen = new THREE.Mesh(screenGeom, screenMat);
            screen.position.z = 0.5;
            phoneBody.add(screen);
            
            // Logo (back)
            const logoGeom = new THREE.CircleGeometry(0.6, 32);
            const logoMat = new THREE.MeshStandardMaterial({
                color: 0x888888,
                metalness: 1.0,
                roughness: 0.1
            });
            const logo = new THREE.Mesh(logoGeom, logoMat);
            logo.position.set(0, 0, 0);
            logo.rotation.y = Math.PI;
            phoneBody.add(logo);
            
            // Side buttons (power and volume)
            // Power button (right side)
            const powerButtonGeom = new THREE.BoxGeometry(0.15, 0.08, 1.2);
            const buttonMat = new THREE.MeshStandardMaterial({
                color: 0x333333,
                metalness: 0.9,
                roughness: 0.3
            });
            const powerButton = new THREE.Mesh(powerButtonGeom, buttonMat);
            powerButton.position.set(3.85, 0, 2);
            phoneBody.add(powerButton);
            
            // Volume buttons (left side)
            const volumeUpGeom = new THREE.BoxGeometry(0.15, 0.08, 1);
            const volumeUp = new THREE.Mesh(volumeUpGeom, buttonMat.clone());
            volumeUp.position.set(-3.85, 0, 3);
            phoneBody.add(volumeUp);
            
            const volumeDownGeom = new THREE.BoxGeometry(0.15, 0.08, 1);
            const volumeDown = new THREE.Mesh(volumeDownGeom, buttonMat.clone());
            volumeDown.position.set(-3.85, 0, 1.2);
            phoneBody.add(volumeDown);
            
            // Mute switch (left side, top)
            const muteSwitchGeom = new THREE.BoxGeometry(0.15, 0.08, 0.6);
            const muteSwitch = new THREE.Mesh(muteSwitchGeom, buttonMat.clone());
            muteSwitch.position.set(-3.85, 0, 5);
            phoneBody.add(muteSwitch);
            
            // Antenna bands (visible on edges)
            const antennaBandMat = new THREE.MeshStandardMaterial({
                color: 0xcccccc,
                metalness: 1.0,
                roughness: 0.2
            });
            
            // Top antenna band
            const topBandGeom = new THREE.BoxGeometry(7.5, 0.1, 0.2);
            const topBand = new THREE.Mesh(topBandGeom, antennaBandMat);
            topBand.position.set(0, 0, 7.4);
            phoneBody.add(topBand);
            
            // Bottom antenna band
            const bottomBand = new THREE.Mesh(topBandGeom.clone(), antennaBandMat.clone());
            bottomBand.position.set(0, 0, -7.4);
            phoneBody.add(bottomBand);
            
            // Side antenna bands
            const sideBandGeom = new THREE.BoxGeometry(0.2, 0.1, 15);
            const leftBand = new THREE.Mesh(sideBandGeom, antennaBandMat.clone());
            leftBand.position.set(-3.7, 0, 0);
            phoneBody.add(leftBand);
            
            const rightBand = new THREE.Mesh(sideBandGeom.clone(), antennaBandMat.clone());
            rightBand.position.set(3.7, 0, 0);
            phoneBody.add(rightBand);
            
            // RF antenna modules (small visible modules on corners)
            const rfModuleGeom = new THREE.BoxGeometry(0.8, 0.15, 0.8);
            const rfModuleMat = new THREE.MeshStandardMaterial({
                color: 0xef4444,
                emissive: 0xef4444,
                emissiveIntensity: 0.3,
                metalness: 0.7,
                roughness: 0.3
            });
            
            // Top-right corner (5G mmWave)
            const rfModule1 = new THREE.Mesh(rfModuleGeom, rfModuleMat.clone());
            rfModule1.position.set(3.2, 0, 6.5);
            phoneBody.add(rfModule1);
            
            // Top-left corner (WiFi)
            const rfModule2 = new THREE.Mesh(rfModuleGeom, rfModuleMat.clone());
            rfModule2.position.set(-3.2, 0, 6.5);
            phoneBody.add(rfModule2);
            
            // Bottom-right corner (Sub-6 GHz)
            const rfModule3 = new THREE.Mesh(rfModuleGeom, rfModuleMat.clone());
            rfModule3.position.set(3.2, 0, -6.5);
            phoneBody.add(rfModule3);
            
            // Bottom-left corner (GPS)
            const rfModule4 = new THREE.Mesh(rfModuleGeom, rfModuleMat.clone());
            rfModule4.position.set(-3.2, 0, -6.5);
            phoneBody.add(rfModule4);
            
            // Internal components (cutaway view - side panel removed)
            const internalGroup = new THREE.Group();
            internalGroup.position.set(2, 0, 0);
            internalGroup.scale.set(0.65, 0.65, 0.65);
            phoneBody.add(internalGroup);
            
            // PCB (green)
            const pcbGeom = new THREE.BoxGeometry(6, 0.15, 13);
            const pcb = new THREE.Mesh(pcbGeom, materials.pcb);
            internalGroup.add(pcb);
            
            // Main processor (A-series chip)
            const processorGeom = new THREE.BoxGeometry(1.8, 0.25, 1.8);
            const processorMat = new THREE.MeshStandardMaterial({
                color: 0x1a1a1a,
                metalness: 0.9,
                roughness: 0.1
            });
            const processor = new THREE.Mesh(processorGeom, processorMat);
            processor.position.set(0, 0.2, 0);
            internalGroup.add(processor);
            
            // RF chip
            const rfChipGeom = new THREE.BoxGeometry(1.2, 0.2, 1.2);
            const rfChipMat = new THREE.MeshStandardMaterial({
                color: 0x2a2a2a,
                metalness: 0.85,
                roughness: 0.15
            });
            const rfChip = new THREE.Mesh(rfChipGeom, rfChipMat);
            rfChip.position.set(0, 0.2, 3);
            internalGroup.add(rfChip);
            
            // SAW filters (6 small yellow components)
            const sawPositions = [
                [-2, -2], [0, -2], [2, -2],
                [-2, 2], [0, 2], [2, 2]
            ];
            
            sawPositions.forEach(pos => {
                const sawGeom = new THREE.BoxGeometry(0.6, 0.18, 0.5);
                const sawMat = new THREE.MeshStandardMaterial({
                    color: 0xd4af37,
                    metalness: 0.8,
                    roughness: 0.3,
                    emissive: 0xaa8800,
                    emissiveIntensity: 0.3
                });
                const saw = new THREE.Mesh(sawGeom, sawMat);
                saw.position.set(pos[0], 0.18, pos[1]);
                internalGroup.add(saw);
                
                // Label
                const labelCanvas = document.createElement('canvas');
                labelCanvas.width = 64;
                labelCanvas.height = 32;
                const ctx = labelCanvas.getContext('2d');
                ctx.fillStyle = '#000000';
                ctx.font = 'Bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('SAW', 32, 20);
                
                const labelTexture = new THREE.CanvasTexture(labelCanvas);
                const labelMat2 = new THREE.SpriteMaterial({ map: labelTexture });
                const labelSprite = new THREE.Sprite(labelMat2);
                labelSprite.position.set(pos[0], 0.5, pos[1]);
                labelSprite.scale.set(0.8, 0.4, 1);
                internalGroup.add(labelSprite);
            });
            
            // Battery
            const batteryGeom = new THREE.BoxGeometry(5, 0.3, 9);
            const batteryMat = new THREE.MeshStandardMaterial({
                color: 0x4a4a4a,
                metalness: 0.6,
                roughness: 0.4
            });
            const battery = new THREE.Mesh(batteryGeom, batteryMat);
            battery.position.set(0, -0.3, -2);
            internalGroup.add(battery);
            
            // Antenna traces (gold lines)
            for (let i = 0; i < 6; i++) {
                const traceGeom = new THREE.BoxGeometry(0.05, 0.02, 5);
                const traceMat = new THREE.MeshStandardMaterial({
                    color: 0xffcc00,
                    metalness: 0.95,
                    roughness: 0.05,
                    emissive: 0xff9900,
                    emissiveIntensity: 0.4
                });
                const trace = new THREE.Mesh(traceGeom, traceMat);
                trace.position.set(
                    i * 1 - 2.5,
                    0.1,
                    2
                );
                internalGroup.add(trace);
            }
            
            // Signal particles
            for (let i = 0; i < 80; i++) {
                const sigGeom = new THREE.SphereGeometry(0.15, 8, 8);
                const sigMat = new THREE.MeshBasicMaterial({
                    color: 0xff00ff,
                    transparent: true,
                    opacity: 0.8
                });
                const sig = new THREE.Mesh(sigGeom, sigMat);
                sig.position.set(
                    (Math.random() - 0.5) * 25,
                    (Math.random() - 0.5) * 15,
                    (Math.random() - 0.5) * 25
                );
                sig.userData.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.5,
                    (Math.random() - 0.5) * 0.3,
                    (Math.random() - 0.5) * 0.5
                );
                group.add(sig);
                anims.push({ type: 'rfParticle', obj: sig });
            }
            
            // Sine and Cosine wave lines passing left to right through phone
            // Sine waves (cyan) - thin horizontal lines
            for (let waveNum = 0; waveNum < 8; waveNum++) {
                const waveGeom = new THREE.TorusGeometry(5 + waveNum * 4, 0.15, 8, 64, Math.PI);
                const wave = new THREE.Mesh(
                    waveGeom,
                    new THREE.MeshBasicMaterial({
                        color: 0x00ffff,
                        emissive: 0x00ffff,
                        emissiveIntensity: 0.8,
                        transparent: true,
                        opacity: 0.7 - waveNum * 0.05
                    })
                );
                wave.position.set(0, 10, 0);
                wave.rotation.y = Math.PI / 2;
                wave.rotation.z = Math.PI / 2;
                group.add(wave);
                anims.push({ type: 'sineWave', obj: wave, i: waveNum });
            }
            
            // Cosine waves (red/pink) - thin horizontal lines
            for (let waveNum = 0; waveNum < 8; waveNum++) {
                const waveGeom = new THREE.TorusGeometry(5 + waveNum * 4, 0.15, 8, 64, Math.PI);
                const wave = new THREE.Mesh(
                    waveGeom,
                    new THREE.MeshBasicMaterial({
                        color: 0xff0066,
                        emissive: 0xff0066,
                        emissiveIntensity: 0.8,
                        transparent: true,
                        opacity: 0.7 - waveNum * 0.05
                    })
                );
                wave.position.set(0, 10, 0);
                wave.rotation.y = -Math.PI / 2;
                wave.rotation.z = Math.PI / 2;
                group.add(wave);
                anims.push({ type: 'cosineWave', obj: wave, i: waveNum });
            }
        }
        
        function buildSAWDevice() {
            const group = currentGroup;
            
            // Piezoelectric substrate (LiNbO3)
            const substrate = new THREE.Mesh(
                new THREE.BoxGeometry(100, 4, 50),
                materials.piezo()
            );
            substrate.position.y = -10;
            group.add(substrate);
            addLabel(substrate, 'LiNbO₃ Substrate', 'Piezoelectric', {y: 0});
            
            // Input IDT - Copper interdigital transducer
            const idtFingers = 16;
            const fingerSpacing = 2;
            
            // Input IDT reference for label
            const inputIDTRef = new THREE.Object3D();
            inputIDTRef.position.set(-27, -7.5, 0);
            group.add(inputIDTRef);
            addLabel(inputIDTRef, 'Input IDT', 'Copper fingers', {y: 2});
            
            // Input IDT fingers
            for (let i = 0; i < idtFingers; i++) {
                const finger = new THREE.Mesh(
                    new THREE.BoxGeometry(0.6, 1.5, 18),
                    materials.copper()
                );
                finger.position.set(-35 + i * fingerSpacing, -7.5, 0);
                group.add(finger);
                anims.push({ type: 'idtFinger', obj: finger, i, side: 'input' });
            }
            
            // Output IDT reference for label
            const outputIDTRef = new THREE.Object3D();
            outputIDTRef.position.set(23, -7.5, 0);
            group.add(outputIDTRef);
            addLabel(outputIDTRef, 'Output IDT', 'Signal reception', {y: 2});
            
            // Output IDT fingers
            for (let i = 0; i < idtFingers; i++) {
                const finger = new THREE.Mesh(
                    new THREE.BoxGeometry(0.6, 1.5, 18),
                    materials.copper()
                );
                finger.position.set(15 + i * fingerSpacing, -7.5, 0);
                group.add(finger);
                anims.push({ type: 'idtFinger', obj: finger, i, side: 'output' });
            }
            
            // Bus bars (copper)
            const busBars = [
                { pos: [-27, -7.5, 11], size: [18, 0.8, 2] },
                { pos: [-27, -7.5, -11], size: [18, 0.8, 2] },
                { pos: [23, -7.5, 11], size: [18, 0.8, 2] },
                { pos: [23, -7.5, -11], size: [18, 0.8, 2] }
            ];
            
            busBars.forEach(bar => {
                const mesh = new THREE.Mesh(
                    new THREE.BoxGeometry(...bar.size),
                    materials.copper()
                );
                mesh.position.set(...bar.pos);
                group.add(mesh);
            });
            
            // Central region for phononic crystal (highlighted)
            const centralZone = new THREE.Mesh(
                new THREE.BoxGeometry(30, 0.5, 25),
                new THREE.MeshStandardMaterial({
                    color: 0x1e3a5f,
                    emissive: 0x1e3a5f,
                    emissiveIntensity: 0.15,
                    transparent: true,
                    opacity: 0.7
                })
            );
            centralZone.position.set(-6, -7.5, 0);
            group.add(centralZone);
            addLabel(centralZone, 'SAW Region', 'Phononic crystal zone', {y: 2});
            
            // Surface acoustic waves (sinusoidal wave fronts)
            for (let w = 0; w < 8; w++) {
                const wavePoints = [];
                for (let i = 0; i <= 40; i++) {
                    const x = -20 + (i / 40) * 60;
                    const z = Math.sin(i * 0.3 + w * 0.5) * 8;
                    wavePoints.push(new THREE.Vector3(x, -6.5, z));
                }
                const waveGeom = new THREE.BufferGeometry().setFromPoints(wavePoints);
                const wave = new THREE.Line(
                    waveGeom,
                    new THREE.LineBasicMaterial({
                        color: 0xf59e0b,
                        transparent: true,
                        opacity: 0.8
                    })
                );
                group.add(wave);
                anims.push({ type: 'sawWaveLine', obj: wave, offset: w * 0.1 });
            }
            
            // Wave amplitude markers
            for (let i = 0; i < 10; i++) {
                const marker = new THREE.Mesh(
                    new THREE.SphereGeometry(0.8, 8, 8),
                    new THREE.MeshStandardMaterial({
                        color: 0xfcd34d,
                        emissive: 0xfcd34d,
                        emissiveIntensity: 0.5
                    })
                );
                group.add(marker);
                anims.push({ type: 'waveMarker', obj: marker, offset: i * 0.1 });
            }
        }
        
        function buildTopologicalCrystal() {
            const group = currentGroup;
            
            // === THIN METALLIC SUBSTRATE (GST-based Valley Hall metamaterial) ===
            const substrateGeo = new THREE.BoxGeometry(140, 1.2, 80);
            const substrateMat = new THREE.MeshPhysicalMaterial({
                color: 0x3a5a7a,
                roughness: 0.22,
                metalness: 0.88,
                clearcoat: 0.75,
                clearcoatRoughness: 0.25
            });
            const substrate = new THREE.Mesh(substrateGeo, substrateMat);
            substrate.position.y = 0;
            substrate.receiveShadow = true;
            substrate.castShadow = true;
            group.add(substrate);
            
            // === INPUT IDT (Left side, horizontal fingers) ===
            const buildMetallicIDT = (zPos, label) => {
                const idtGroup = new THREE.Group();
                idtGroup.position.z = zPos;
                
                // IDT fingers (horizontal orientation - perpendicular to wave direction)
                for (let i = 0; i < 20; i++) {
                    const fingerGeo = new THREE.BoxGeometry(25, 0.15, 0.4);
                    const fingerMat = new THREE.MeshPhysicalMaterial({
                        color: 0xfbbf24,
                        roughness: 0.2,
                        metalness: 0.96,
                        emissive: 0xf59e0b,
                        emissiveIntensity: 0.15,
                        clearcoat: 0.7
                    });
                    const finger = new THREE.Mesh(fingerGeo, fingerMat);
                    finger.position.set(0, 0.75, (i - 10) * 0.9);
                    finger.castShadow = true;
                    idtGroup.add(finger);
                }
                
                // Bus bars (vertical)
                const busGeo = new THREE.BoxGeometry(2, 0.12, 18);
                const busMat = new THREE.MeshPhysicalMaterial({
                    color: 0xfbbf24,
                    roughness: 0.18,
                    metalness: 0.96,
                    clearcoat: 0.7
                });
                
                const leftBus = new THREE.Mesh(busGeo, busMat);
                leftBus.position.set(-13, 0.72, 0);
                idtGroup.add(leftBus);
                
                const rightBus = new THREE.Mesh(busGeo, busMat);
                rightBus.position.set(13, 0.72, 0);
                idtGroup.add(rightBus);
                
                group.add(idtGroup);
                addLabel(idtGroup, label, 'Gold IDT', {y: 2, z: zPos > 0 ? 5 : -5});
            };
            
            buildMetallicIDT(-32, 'Input IDT');
            buildMetallicIDT(32, 'Output IDT');
            
            // === HORIZONTAL IDTs (Left and Right sides for edge state propagation) ===
            const buildHorizontalIDT = (xPos, label) => {
                const idtGroup = new THREE.Group();
                idtGroup.position.x = xPos;
                
                // IDT fingers (vertical orientation - perpendicular to horizontal wave)
                for (let i = 0; i < 16; i++) {
                    const fingerGeo = new THREE.BoxGeometry(0.35, 0.15, 18);
                    const fingerMat = new THREE.MeshPhysicalMaterial({
                        color: 0xfbbf24,
                        roughness: 0.2,
                        metalness: 0.96,
                        emissive: 0xf59e0b,
                        emissiveIntensity: 0.15,
                        clearcoat: 0.7
                    });
                    const finger = new THREE.Mesh(fingerGeo, fingerMat);
                    finger.position.set((i - 8) * 0.7, 0.75, 0);
                    finger.castShadow = true;
                    idtGroup.add(finger);
                }
                
                // Bus bars (horizontal)
                const busGeo = new THREE.BoxGeometry(12, 0.12, 1.8);
                const busMat = new THREE.MeshPhysicalMaterial({
                    color: 0xfbbf24,
                    roughness: 0.18,
                    metalness: 0.96,
                    clearcoat: 0.7
                });
                
                const topBus = new THREE.Mesh(busGeo, busMat);
                topBus.position.set(0, 0.72, -10);
                idtGroup.add(topBus);
                
                const bottomBus = new THREE.Mesh(busGeo, busMat);
                bottomBus.position.set(0, 0.72, 10);
                idtGroup.add(bottomBus);
                
                group.add(idtGroup);
                addLabel(idtGroup, label, 'Gold IDT', {y: 2, x: xPos > 0 ? 5 : -5});
            };
            
            buildHorizontalIDT(-58, 'Left IDT');
            buildHorizontalIDT(58, 'Right IDT');
            
            // === HEXAGONAL PHONONIC CRYSTAL (EMBEDDED - Short pillars) ===
            // NOW: Domains are PERPENDICULAR to IDT (blue bottom, red top, interface in middle)
            const crystalHexSize = 2.2;
            const crystalRows = 24; // More rows for perpendicular orientation
            const crystalCols = 16; // Fewer columns
            
            for (let row = 0; row < crystalRows; row++) {
                for (let col = 0; col < crystalCols; col++) {
                    // SWAP x and z coordinates to rotate 90 degrees
                    const x = (col - crystalCols/2) * crystalHexSize * 1.5;
                    const z = (row - crystalRows/2) * crystalHexSize * 0.866 * 2 + (col % 2) * crystalHexSize * 0.866;
                    
                    // Skip pillars where IDTs are located
                    const skipForInputIDT = Math.abs(z + 32) < 10; // Input IDT at z=-32
                    const skipForOutputIDT = Math.abs(z - 32) < 10; // Output IDT at z=+32
                    const skipForLeftIDT = Math.abs(x + 58) < 8; // Left IDT at x=-58
                    const skipForRightIDT = Math.abs(x - 58) < 8; // Right IDT at x=+58
                    
                    if (Math.abs(x) < 35 && Math.abs(z) < 38 && !skipForInputIDT && !skipForOutputIDT && !skipForLeftIDT && !skipForRightIDT) {
                        // Determine domain based on Z position (perpendicular to IDT)
                        const isTrivial = z < -3; // Blue bottom
                        const isNonTrivial = z > 3; // Red top
                        const isInterface = !isTrivial && !isNonTrivial; // Yellow middle
                        
                        // EMBEDDED pillars - much shorter (0.4 height instead of 2.5)
                        const pillarRadius = isTrivial ? 0.7 : (isNonTrivial ? 1.1 : 0.9);
                        const pillarHeight = 0.4; // SHORT embedded pillars
                        const pillarGeo = new THREE.CylinderGeometry(pillarRadius, pillarRadius, pillarHeight, 24);
                        const pillarMat = new THREE.MeshPhysicalMaterial({
                            color: isTrivial ? 0x5b9adb : (isNonTrivial ? 0xef6565 : 0xfcd34d),
                            roughness: 0.28,
                            metalness: 0.75,
                            emissive: isTrivial ? 0x3b82f6 : (isNonTrivial ? 0xef4444 : 0xfcd34d),
                            emissiveIntensity: isInterface ? 0.4 : 0.18,
                            clearcoat: 0.5
                        });
                        const pillar = new THREE.Mesh(pillarGeo, pillarMat);
                        pillar.position.set(x, 0.8, z); // Just above substrate (embedded look)
                        pillar.castShadow = true;
                        pillar.receiveShadow = true;
                        group.add(pillar);
                        
                        anims.push({ 
                            type: isInterface ? 'interfacePillar' : (isTrivial ? 'trivialPillar' : 'nontrivialPillar'),
                            obj: pillar,
                            i: row,
                            j: col
                        });
                    }
                }
            }
            
            // === TOPOLOGICAL INTERFACE HIGHLIGHTING (Horizontal band at z=0) ===
            const interfaceGeo = new THREE.BoxGeometry(72, 0.4, 6);
            const interfaceMat = new THREE.MeshStandardMaterial({
                color: 0xfcd34d,
                emissive: 0xfcd34d,
                emissiveIntensity: 0.45,
                transparent: true,
                opacity: 0.35
            });
            const interfaceBand = new THREE.Mesh(interfaceGeo, interfaceMat);
            interfaceBand.position.set(0, 1.1, 0);
            group.add(interfaceBand);
            anims.push({ type: 'topoInterface', obj: interfaceBand });
            addLabel(interfaceBand, 'Topological Interface', 'Edge states propagate here', {y: 2});
            
            // === WAVE PARTICLES (sequential transmission: Input→Output→Left→Right) ===
            // Stage 1: Input IDT to Output IDT (vertical transmission)
            for (let i = 0; i < 20; i++) {
                const waveGeo = new THREE.SphereGeometry(0.45, 16, 16);
                const waveMat = new THREE.MeshStandardMaterial({
                    color: 0xfcd34d,
                    emissive: 0xfcd34d,
                    emissiveIntensity: 1.1,
                    transparent: true,
                    opacity: 0.92
                });
                const wave = new THREE.Mesh(waveGeo, waveMat);
                group.add(wave);
                anims.push({
                    type: 'edgeStateWaveSequential',
                    obj: wave,
                    stage: 1,
                    progress: i / 20,
                    lane: (i % 3) - 1 // Multiple lanes along interface
                });
            }
            
            // Stage 2: Output IDT to Left IDT (horizontal transmission)
            for (let i = 0; i < 20; i++) {
                const waveGeo = new THREE.SphereGeometry(0.45, 16, 16);
                const waveMat = new THREE.MeshStandardMaterial({
                    color: 0x3b82f6,
                    emissive: 0x3b82f6,
                    emissiveIntensity: 1.1,
                    transparent: true,
                    opacity: 0.92
                });
                const wave = new THREE.Mesh(waveGeo, waveMat);
                group.add(wave);
                anims.push({
                    type: 'edgeStateWaveSequential',
                    obj: wave,
                    stage: 2,
                    progress: i / 20,
                    lane: (i % 3) - 1
                });
            }
            
            // Stage 3: Output IDT to Right IDT (horizontal transmission)
            for (let i = 0; i < 20; i++) {
                const waveGeo = new THREE.SphereGeometry(0.45, 16, 16);
                const waveMat = new THREE.MeshStandardMaterial({
                    color: 0xef4444,
                    emissive: 0xef4444,
                    emissiveIntensity: 1.1,
                    transparent: true,
                    opacity: 0.92
                });
                const wave = new THREE.Mesh(waveGeo, waveMat);
                group.add(wave);
                anims.push({
                    type: 'edgeStateWaveSequential',
                    obj: wave,
                    stage: 3,
                    progress: i / 20,
                    lane: (i % 3) - 1
                });
            }
        }
        
        function buildEdgeStatePropagation() {
            const group = currentGroup;
            
            // === BASE SUBSTRATE (THINNER) ===
            const substrateGeo = new THREE.BoxGeometry(150, 0.8, 110);
            const substrateMat = new THREE.MeshPhysicalMaterial({
                color: 0x4a5f7a,
                metalness: 0.3,
                roughness: 0.4,
                clearcoat: 0.3
            });
            const substrate = new THREE.Mesh(substrateGeo, substrateMat);
            substrate.position.y = 0;
            substrate.receiveShadow = true;
            group.add(substrate);
            
            // === TOPOLOGICAL PHONONIC CRYSTAL STRUCTURE ===
            // Create two domains with different configurations for interface
            const hexRadius = 3.0;
            const spacing = 7.5;
            const rows = 17;
            const cols = 21;
            
            // Domain A (left half - smaller circular inclusions in hexagonal pattern)
            for (let row = 0; row < rows; row++) {
                const offsetX = (row % 2) * spacing * 0.5;
                for (let col = 0; col < cols / 2; col++) {
                    const x = -78 + col * spacing + offsetX;
                    const z = -55 + row * spacing * 0.866;
                    
                    // Circular inclusion (small) - METALLIC GOLD
                    const inclusionGeo = new THREE.CylinderGeometry(hexRadius * 0.4, hexRadius * 0.4, 0.4, 32);
                    const inclusionMat = new THREE.MeshStandardMaterial({
                        color: 0xfbbf24,
                        metalness: 0.9,
                        roughness: 0.1,
                        emissive: 0xfbbf24,
                        emissiveIntensity: 0.15
                    });
                    const inclusion = new THREE.Mesh(inclusionGeo, inclusionMat);
                    inclusion.position.set(x, 0.2, z);
                    inclusion.castShadow = true;
                    group.add(inclusion);
                }
            }
            
            // Domain B (right half - larger circular inclusions, inverted band structure)
            for (let row = 0; row < rows; row++) {
                const offsetX = (row % 2) * spacing * 0.5;
                for (let col = Math.floor(cols / 2); col < cols; col++) {
                    const x = -78 + col * spacing + offsetX;
                    const z = -55 + row * spacing * 0.866;
                    
                    // Circular inclusion (large) - METALLIC SILVER
                    const inclusionGeo = new THREE.CylinderGeometry(hexRadius * 0.65, hexRadius * 0.65, 0.4, 32);
                    const inclusionMat = new THREE.MeshStandardMaterial({
                        color: 0xd1d5db,
                        metalness: 0.95,
                        roughness: 0.05,
                        emissive: 0xd1d5db,
                        emissiveIntensity: 0.1
                    });
                    const inclusion = new THREE.Mesh(inclusionGeo, inclusionMat);
                    inclusion.position.set(x, 0.2, z);
                    inclusion.castShadow = true;
                    group.add(inclusion);
                }
            }
            
            // === TOPOLOGICAL INTERFACE (vertical line at x=0) ===
            const interfaceGeo = new THREE.BoxGeometry(1.5, 0.6, 95);
            const interfaceMat = new THREE.MeshStandardMaterial({
                color: 0x22c55e,
                emissive: 0x22c55e,
                emissiveIntensity: 0.6,
                transparent: true,
                opacity: 0.4
            });
            const interfaceLine = new THREE.Mesh(interfaceGeo, interfaceMat);
            interfaceLine.position.set(0, 0.9, 0);
            group.add(interfaceLine);
            anims.push({ type: 'topologicalInterface', obj: interfaceLine });
            
            // === SOURCE (Input excitation at CENTER) ===
            const sourceGeo = new THREE.CylinderGeometry(6, 6, 1.5, 32);
            const sourceMat = new THREE.MeshStandardMaterial({
                color: 0x3b82f6,
                emissive: 0x3b82f6,
                emissiveIntensity: 0.8,
                transparent: true,
                opacity: 0.85
            });
            const source = new THREE.Mesh(sourceGeo, sourceMat);
            source.position.set(0, 0.75, 0);
            group.add(source);
            anims.push({ type: 'sourceGlow', obj: source });
            addLabel(source, 'Central Source', '4-way edge state launch', {y: 7});
            
            // === DEFECT OBSTACLES (at quadrant boundaries) ===
            const defectGeo1 = new THREE.BoxGeometry(6, 2, 6);
            const defectMat1 = new THREE.MeshStandardMaterial({
                color: 0x6b7280,
                metalness: 0.6,
                roughness: 0.3,
                transparent: true,
                opacity: 0.6
            });
            
            // Forward defect (along +Z axis)
            const defect1 = new THREE.Mesh(defectGeo1, defectMat1.clone());
            defect1.position.set(0, 1.0, 30);
            group.add(defect1);
            
            // Backward defect (along -Z axis)
            const defect2 = new THREE.Mesh(defectGeo1.clone(), defectMat1.clone());
            defect2.position.set(0, 1.0, -30);
            group.add(defect2);
            
            // Right defect (along +X axis)
            const defect3 = new THREE.Mesh(defectGeo1.clone(), defectMat1.clone());
            defect3.position.set(40, 1.0, 0);
            group.add(defect3);
            
            // Left defect (along -X axis)
            const defect4 = new THREE.Mesh(defectGeo1.clone(), defectMat1.clone());
            defect4.position.set(-40, 1.0, 0);
            group.add(defect4);
            
            // === EDGE STATE WAVE PARTICLES (4-WAY PROPAGATION FROM CENTER) ===
            // Forward Direction (Green - along +Z)
            for (let i = 0; i < 40; i++) {
                const waveGeo = new THREE.SphereGeometry(0.6, 16, 16);
                const waveMat = new THREE.MeshStandardMaterial({
                    color: 0x22c55e,
                    emissive: 0x22c55e,
                    emissiveIntensity: 1.2,
                    transparent: true,
                    opacity: 0.9
                });
                const wave = new THREE.Mesh(waveGeo, waveMat);
                group.add(wave);
                anims.push({
                    type: 'edgeWaveCardinal',
                    obj: wave,
                    direction: 'forward',
                    phase: (i / 40) * Math.PI * 2,
                    speed: 0.5
                });
            }
            
            // Backward Direction (Amber - along -Z)
            for (let i = 0; i < 40; i++) {
                const waveGeo = new THREE.SphereGeometry(0.6, 16, 16);
                const waveMat = new THREE.MeshStandardMaterial({
                    color: 0xf59e0b,
                    emissive: 0xf59e0b,
                    emissiveIntensity: 1.2,
                    transparent: true,
                    opacity: 0.9
                });
                const wave = new THREE.Mesh(waveGeo, waveMat);
                group.add(wave);
                anims.push({
                    type: 'edgeWaveCardinal',
                    obj: wave,
                    direction: 'backward',
                    phase: (i / 40) * Math.PI * 2,
                    speed: 0.5
                });
            }
            
            // Right Direction (Cyan - along +X)
            for (let i = 0; i < 40; i++) {
                const waveGeo = new THREE.SphereGeometry(0.6, 16, 16);
                const waveMat = new THREE.MeshStandardMaterial({
                    color: 0x06b6d4,
                    emissive: 0x06b6d4,
                    emissiveIntensity: 1.2,
                    transparent: true,
                    opacity: 0.9
                });
                const wave = new THREE.Mesh(waveGeo, waveMat);
                group.add(wave);
                anims.push({
                    type: 'edgeWaveCardinal',
                    obj: wave,
                    direction: 'right',
                    phase: (i / 40) * Math.PI * 2,
                    speed: 0.5
                });
            }
            
            // Left Direction (Purple - along -X)
            for (let i = 0; i < 40; i++) {
                const waveGeo = new THREE.SphereGeometry(0.6, 16, 16);
                const waveMat = new THREE.MeshStandardMaterial({
                    color: 0xa855f7,
                    emissive: 0xa855f7,
                    emissiveIntensity: 1.2,
                    transparent: true,
                    opacity: 0.9
                });
                const wave = new THREE.Mesh(waveGeo, waveMat);
                group.add(wave);
                anims.push({
                    type: 'edgeWaveCardinal',
                    obj: wave,
                    direction: 'left',
                    phase: (i / 40) * Math.PI * 2,
                    speed: 0.5
                });
            }
            
            // === TRAIL EFFECTS (showing four cardinal direction paths) ===
            const directionColors = [
                { color: 0x22c55e, direction: 'forward' },
                { color: 0xf59e0b, direction: 'backward' },
                { color: 0x06b6d4, direction: 'right' },
                { color: 0xa855f7, direction: 'left' }
            ];
            
            directionColors.forEach(dData => {
                for (let i = 0; i < 25; i++) {
                    const trailGeo = new THREE.SphereGeometry(0.35, 12, 12);
                    const trailMat = new THREE.MeshBasicMaterial({
                        color: dData.color,
                        transparent: true,
                        opacity: 0.2
                    });
                    const trail = new THREE.Mesh(trailGeo, trailMat);
                    group.add(trail);
                    anims.push({
                        type: 'trailCardinal',
                        obj: trail,
                        direction: dData.direction,
                        phase: (i / 25) * Math.PI * 2
                    });
                }
            });
            
            // === DIRECTIONAL ARROWS (4-WAY CARDINAL PROPAGATION) ===
            const arrowGeometry1 = new THREE.ConeGeometry(2, 5, 4);
            
            // Forward arrow (Green - pointing along +Z)
            const arrow1 = new THREE.Mesh(arrowGeometry1.clone(), new THREE.MeshBasicMaterial({
                color: 0x22c55e,
                transparent: true,
                opacity: 0.6
            }));
            arrow1.rotation.set(Math.PI / 2, 0, 0);
            arrow1.position.set(0, 2, 35);
            group.add(arrow1);
            anims.push({ type: 'arrowPulse', obj: arrow1 });
            
            // Backward arrow (Amber - pointing along -Z)
            const arrow2 = new THREE.Mesh(arrowGeometry1.clone(), new THREE.MeshBasicMaterial({
                color: 0xf59e0b,
                transparent: true,
                opacity: 0.6
            }));
            arrow2.rotation.set(-Math.PI / 2, 0, 0);
            arrow2.position.set(0, 2, -35);
            group.add(arrow2);
            anims.push({ type: 'arrowPulse', obj: arrow2 });
            
            // Right arrow (Cyan - pointing along +X)
            const arrow3 = new THREE.Mesh(arrowGeometry1.clone(), new THREE.MeshBasicMaterial({
                color: 0x06b6d4,
                transparent: true,
                opacity: 0.6
            }));
            arrow3.rotation.set(0, 0, -Math.PI / 2);
            arrow3.position.set(45, 2, 0);
            group.add(arrow3);
            anims.push({ type: 'arrowPulse', obj: arrow3 });
            
            // Left arrow (Purple - pointing along -X)
            const arrow4 = new THREE.Mesh(arrowGeometry1.clone(), new THREE.MeshBasicMaterial({
                color: 0xa855f7,
                transparent: true,
                opacity: 0.6
            }));
            arrow4.rotation.set(0, 0, Math.PI / 2);
            arrow4.position.set(-45, 2, 0);
            group.add(arrow4);
            anims.push({ type: 'arrowPulse', obj: arrow4 });
            
            // === BACKSCATTERING SUPPRESSION VISUALIZATION ===
            // Show attempted backscatter being blocked near defects
            const directions = ['forward', 'backward', 'right', 'left'];
            directions.forEach((dir, dIdx) => {
                for (let i = 0; i < 5; i++) {
                    const backscatterGeo = new THREE.SphereGeometry(0.4, 12, 12);
                    const backscatterMat = new THREE.MeshBasicMaterial({
                        color: 0xff6b6b,
                        transparent: true,
                        opacity: 0.3
                    });
                    const backscatter = new THREE.Mesh(backscatterGeo, backscatterMat);
                    group.add(backscatter);
                    anims.push({
                        type: 'backscatterCardinal',
                        obj: backscatter,
                        direction: dir,
                        phase: (i / 5 + dIdx * 0.25) * Math.PI * 2
                    });
                }
            });
            
            // === INFO TEXT OVERLAY (using sprites) ===
            // "4-WAY EDGE STATE ROUTING" text
            const textGeo = new THREE.PlaneGeometry(20, 3);
            const canvas = document.createElement('canvas');
            canvas.width = 640;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
            ctx.fillRect(0, 0, 640, 128);
            ctx.fillStyle = '#3b82f6';
            ctx.font = 'bold 44px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('4-WAY EDGE STATE ROUTING', 320, 80);
            const textTexture = new THREE.CanvasTexture(canvas);
            const textMat = new THREE.MeshBasicMaterial({
                map: textTexture,
                transparent: true,
                side: THREE.DoubleSide
            });
            const textMesh = new THREE.Mesh(textGeo, textMat);
            textMesh.position.set(0, 10, 0);
            textMesh.rotation.x = -0.3;
            group.add(textMesh);
            anims.push({ type: 'textGlow', obj: textMesh });
            
            camera.position.set(0, 90, 130);
            camera.lookAt(0, 0, 0);
        }
        
        function buildDirectionalRouting() {
            const group = currentGroup;
            
            // === THIN METALLIC BASE SUBSTRATE ===
            const substrateGeo = new THREE.BoxGeometry(140, 1.8, 100);
            const substrateMat = new THREE.MeshPhysicalMaterial({
                color: 0x5a7a9a,
                roughness: 0.25,
                metalness: 0.88,
                clearcoat: 0.65,
                clearcoatRoughness: 0.25
            });
            const substrate = new THREE.Mesh(substrateGeo, substrateMat);
            substrate.position.y = 0;
            substrate.receiveShadow = true;
            substrate.castShadow = true;
            group.add(substrate);
            
            // === WAVEGUIDE CHANNELS (Metallic raised paths) ===
            // Trivial domain waveguide - Left upper
            const trivialLeftGeo = new THREE.BoxGeometry(35, 0.8, 25);
            const trivialMat = new THREE.MeshPhysicalMaterial({
                color: 0x6b9bd1,
                roughness: 0.3,
                metalness: 0.75,
                clearcoat: 0.5,
                emissive: 0x3b82f6,
                emissiveIntensity: 0.12
            });
            const trivialLeft = new THREE.Mesh(trivialLeftGeo, trivialMat);
            trivialLeft.position.set(-32, 1.3, 28);
            trivialLeft.castShadow = true;
            group.add(trivialLeft);
            
            // Trivial domain waveguide - Right upper
            const trivialRight = new THREE.Mesh(trivialLeftGeo, trivialMat.clone());
            trivialRight.position.set(32, 1.3, 28);
            trivialRight.castShadow = true;
            group.add(trivialRight);
            
            // Non-trivial core waveguide (Center channel)
            const nonTrivialGeo = new THREE.BoxGeometry(28, 1.0, 75);
            const nonTrivialMat = new THREE.MeshPhysicalMaterial({
                color: 0xd47d7d,
                roughness: 0.3,
                metalness: 0.75,
                clearcoat: 0.5,
                emissive: 0xef4444,
                emissiveIntensity: 0.15
            });
            const nonTrivial = new THREE.Mesh(nonTrivialGeo, nonTrivialMat);
            nonTrivial.position.set(0, 1.4, 0);
            nonTrivial.castShadow = true;
            group.add(nonTrivial);
            addLabel(nonTrivial, 'Non-trivial Core', 'Topological routing', {y: 2});
            
            // === GOLD TOPOLOGICAL INTERFACE CHANNELS ===
            // Left interface channel
            const interfaceGeo = new THREE.BoxGeometry(2.5, 1.2, 78);
            const interfaceMat = new THREE.MeshPhysicalMaterial({
                color: 0xfcd34d,
                roughness: 0.2,
                metalness: 0.92,
                clearcoat: 0.7,
                emissive: 0xfcd34d,
                emissiveIntensity: 0.35
            });
            const interfaceLeft = new THREE.Mesh(interfaceGeo, interfaceMat);
            interfaceLeft.position.set(-13, 1.5, 0);
            interfaceLeft.castShadow = true;
            group.add(interfaceLeft);
            anims.push({ type: 'routingInterface', obj: interfaceLeft, side: 'left' });
            
            // Right interface channel
            const interfaceRight = new THREE.Mesh(interfaceGeo, interfaceMat.clone());
            interfaceRight.position.set(13, 1.5, 0);
            interfaceRight.castShadow = true;
            group.add(interfaceRight);
            anims.push({ type: 'routingInterface', obj: interfaceRight, side: 'right' });
            
            addLabel(interfaceLeft, 'Left Interface', 'Valley-polarized', {y: 2, x: -5});
            addLabel(interfaceRight, 'Right Interface', 'Opposite valley', {y: 2, x: 5});
            
            // === INPUT/OUTPUT PORTS (Metallic connectors) ===
            // Input port (center bottom)
            const inputPortGeo = new THREE.BoxGeometry(10, 1.5, 10);
            const inputPortMat = new THREE.MeshPhysicalMaterial({
                color: 0x22c55e,
                roughness: 0.25,
                metalness: 0.9,
                emissive: 0x22c55e,
                emissiveIntensity: 0.4,
                clearcoat: 0.6
            });
            const inputPort = new THREE.Mesh(inputPortGeo, inputPortMat);
            inputPort.position.set(0, 1.6, -42);
            inputPort.castShadow = true;
            group.add(inputPort);
            anims.push({ type: 'routingPort', obj: inputPort, portType: 'input' });
            addLabel(inputPort, 'Input Port', 'Multi-frequency signal', {y: 3});
            
            // Output Port A (left top) - Orange for f1
            const outputAGeo = new THREE.BoxGeometry(12, 1.8, 12);
            const outputAMat = new THREE.MeshPhysicalMaterial({
                color: 0xf59e0b,
                roughness: 0.2,
                metalness: 0.92,
                emissive: 0xf59e0b,
                emissiveIntensity: 0.45,
                clearcoat: 0.7
            });
            const outputA = new THREE.Mesh(outputAGeo, outputAMat);
            outputA.position.set(-32, 1.8, 42);
            outputA.castShadow = true;
            group.add(outputA);
            anims.push({ type: 'routingPort', obj: outputA, portType: 'outputA' });
            addLabel(outputA, 'Port A (f₁)', 'Frequency 1 output', {y: 3});
            
            // Output Port B (right top) - Purple for f2
            const outputBMat = new THREE.MeshPhysicalMaterial({
                color: 0x8b5cf6,
                roughness: 0.2,
                metalness: 0.92,
                emissive: 0x8b5cf6,
                emissiveIntensity: 0.45,
                clearcoat: 0.7
            });
            const outputB = new THREE.Mesh(outputAGeo, outputBMat);
            outputB.position.set(32, 1.8, 42);
            outputB.castShadow = true;
            group.add(outputB);
            anims.push({ type: 'routingPort', obj: outputB, portType: 'outputB' });
            addLabel(outputB, 'Port B (f₂)', 'Frequency 2 output', {y: 3});
            
            // === WAVE PARTICLE ROUTING VISUALIZATION ===
            // Input waves (green) - from input port upward
            for (let i = 0; i < 20; i++) {
                const waveGeo = new THREE.SphereGeometry(0.5, 16, 16);
                const waveMat = new THREE.MeshStandardMaterial({
                    color: 0x22c55e,
                    emissive: 0x22c55e,
                    emissiveIntensity: 0.9,
                    transparent: true,
                    opacity: 0.85
                });
                const wave = new THREE.Mesh(waveGeo, waveMat);
                group.add(wave);
                anims.push({ type: 'routingInputWave', obj: wave, progress: i / 20 });
            }
            
            // f1 waves (orange) - routing to Port A (left)
            for (let i = 0; i < 25; i++) {
                const waveGeo = new THREE.SphereGeometry(0.45, 16, 16);
                const waveMat = new THREE.MeshStandardMaterial({
                    color: 0xf59e0b,
                    emissive: 0xf59e0b,
                    emissiveIntensity: 1.0,
                    transparent: true,
                    opacity: 0.9
                });
                const wave = new THREE.Mesh(waveGeo, waveMat);
                group.add(wave);
                anims.push({ type: 'routingF1Wave', obj: wave, progress: i / 25 });
            }
            
            // f2 waves (purple) - routing to Port B (right)
            for (let i = 0; i < 25; i++) {
                const waveGeo = new THREE.SphereGeometry(0.45, 16, 16);
                const waveMat = new THREE.MeshStandardMaterial({
                    color: 0x8b5cf6,
                    emissive: 0x8b5cf6,
                    emissiveIntensity: 1.0,
                    transparent: true,
                    opacity: 0.9
                });
                const wave = new THREE.Mesh(waveGeo, waveMat);
                group.add(wave);
                anims.push({ type: 'routingF2Wave', obj: wave, progress: i / 25 });
            }
            
            // === CORNER NAVIGATION MARKERS ===
            // Show waves navigating sharp corners without backscattering
            const cornerPositions = [
                { x: -13, z: -15 }, { x: -13, z: 15 },  // Left interface corners
                { x: 13, z: -15 }, { x: 13, z: 15 }     // Right interface corners
            ];
            
            cornerPositions.forEach((pos, idx) => {
                const cornerMarkerGeo = new THREE.TorusGeometry(2, 0.3, 16, 32);
                const cornerMarkerMat = new THREE.MeshStandardMaterial({
                    color: 0xfcd34d,
                    emissive: 0xfcd34d,
                    emissiveIntensity: 0.6,
                    transparent: true,
                    opacity: 0.6
                });
                const cornerMarker = new THREE.Mesh(cornerMarkerGeo, cornerMarkerMat);
                cornerMarker.position.set(pos.x, 1.5, pos.z);
                cornerMarker.rotation.x = Math.PI / 2;
                group.add(cornerMarker);
                anims.push({ type: 'cornerMarker', obj: cornerMarker, idx });
            });
        }
        
        function buildHighQ() {
            const group = currentGroup;
            
            // ZOOM IN: Scale everything up 1.8x
            const zoomScale = 1.8;
            const highQGroup = new THREE.Group();
            highQGroup.scale.set(zoomScale, zoomScale, zoomScale);
            group.add(highQGroup);
            
            // === THIN METALLIC SUBSTRATE (Like reference image) ===
            const resonatorBase = new THREE.Mesh(
                new THREE.BoxGeometry(70, 1.2, 50),
                new THREE.MeshPhysicalMaterial({
                    color: 0x5a6d85,
                    roughness: 0.2,
                    metalness: 0.92,
                    clearcoat: 0.8,
                    clearcoatRoughness: 0.18
                })
            );
            resonatorBase.position.set(0, 0, 0);
            resonatorBase.castShadow = true;
            resonatorBase.receiveShadow = true;
            highQGroup.add(resonatorBase);
            
            // === HIGH-Q TOPOLOGICAL CAVITY (Larger, more prominent gold ring) ===
            const highQCavityGeo = new THREE.TorusGeometry(14, 2.2, 32, 96);
            const highQMat = new THREE.MeshPhysicalMaterial({
                color: 0xfbbf24,
                roughness: 0.15,
                metalness: 0.97,
                clearcoat: 0.85,
                emissive: 0xf59e0b,
                emissiveIntensity: 0.5
            });
            const highQCavity = new THREE.Mesh(highQCavityGeo, highQMat);
            highQCavity.position.set(0, 1.8, 0);
            highQCavity.rotation.x = Math.PI / 2;
            highQCavity.castShadow = true;
            highQGroup.add(highQCavity);
            anims.push({ type: 'highQResonator', obj: highQCavity });
            addLabel(highQCavity, 'High-Q Resonator', 'Q > 10⁶', {y: 5});
            
            // === LOW-Q REFERENCE CAVITY (Smaller, grey/silver) ===
            const lowQCavityGeo = new THREE.TorusGeometry(8, 1.5, 24, 64);
            const lowQMat = new THREE.MeshPhysicalMaterial({
                color: 0x9ca3af,
                roughness: 0.3,
                metalness: 0.85,
                clearcoat: 0.6,
                emissive: 0x6b7280,
                emissiveIntensity: 0.25
            });
            const lowQCavity = new THREE.Mesh(lowQCavityGeo, lowQMat);
            lowQCavity.position.set(-22, 1.5, 0);
            lowQCavity.rotation.x = Math.PI / 2;
            lowQCavity.castShadow = true;
            highQGroup.add(lowQCavity);
            addLabel(lowQCavity, 'Low-Q Reference', 'Q ≈ 10³', {y: 4, x: -5});
            
            // === INPUT PORT (Green metallic cylinder) ===
            const inputPortGeo = new THREE.CylinderGeometry(1.8, 2.0, 3.5, 32);
            const inputPortMat = new THREE.MeshPhysicalMaterial({
                color: 0x10b981,
                roughness: 0.18,
                metalness: 0.94,
                emissive: 0x22c55e,
                emissiveIntensity: 0.55,
                clearcoat: 0.75
            });
            const inputPort = new THREE.Mesh(inputPortGeo, inputPortMat);
            inputPort.position.set(0, 2.0, -17);
            inputPort.rotation.x = Math.PI / 2;
            inputPort.castShadow = true;
            highQGroup.add(inputPort);
            anims.push({ type: 'highQPort', obj: inputPort, portType: 'input' });
            addLabel(inputPort, 'Input', 'Broadband signal', {y: 3, z: -3});
            
            // === OUTPUT PORT (Green metallic cylinder) ===
            const outputPort = new THREE.Mesh(inputPortGeo, inputPortMat.clone());
            outputPort.position.set(0, 2.0, 17);
            outputPort.rotation.x = Math.PI / 2;
            outputPort.castShadow = true;
            highQGroup.add(outputPort);
            anims.push({ type: 'highQPort', obj: outputPort, portType: 'output' });
            addLabel(outputPort, 'Output', 'Filtered signal', {y: 3, z: 3});
            
            // === WAVEGUIDE CHANNELS (Gold metallic paths) ===
            // Input channel
            const inputChannelGeo = new THREE.BoxGeometry(4, 0.8, 14);
            const channelMat = new THREE.MeshPhysicalMaterial({
                color: 0xfbbf24,
                roughness: 0.18,
                metalness: 0.92,
                emissive: 0xf59e0b,
                emissiveIntensity: 0.3,
                clearcoat: 0.75
            });
            const inputChannel = new THREE.Mesh(inputChannelGeo, channelMat);
            inputChannel.position.set(0, 1.3, -9);
            inputChannel.castShadow = true;
            highQGroup.add(inputChannel);
            
            // Output channel
            const outputChannel = new THREE.Mesh(inputChannelGeo, channelMat.clone());
            outputChannel.position.set(0, 1.3, 9);
            outputChannel.castShadow = true;
            highQGroup.add(outputChannel);
            
            // === DEFECT (Red transparent cube showing no backscatter) ===
            const defectGeo = new THREE.BoxGeometry(4, 4, 4);
            const defectMat = new THREE.MeshPhysicalMaterial({
                color: 0xef4444,
                roughness: 0.25,
                metalness: 0.75,
                transparent: true,
                opacity: 0.65,
                emissive: 0xef4444,
                emissiveIntensity: 0.4,
                clearcoat: 0.5
            });
            const defect = new THREE.Mesh(defectGeo, defectMat);
            defect.position.set(14, 2.0, 0);
            defect.rotation.y = Math.PI / 4;
            defect.castShadow = true;
            highQGroup.add(defect);
            anims.push({ type: 'highQDefect', obj: defect });
            addLabel(defect, 'Defect', 'No backscatter', {y: 3, x: 3});
            
            // === CIRCULATING WAVE PARTICLES (Enhanced, more visible) ===
            for (let i = 0; i < 60; i++) {
                const waveGeo = new THREE.SphereGeometry(0.5, 16, 16);
                const waveMat = new THREE.MeshStandardMaterial({
                    color: 0xfbbf24,
                    emissive: 0xfbbf24,
                    emissiveIntensity: 1.2,
                    transparent: true,
                    opacity: 0.95
                });
                const wave = new THREE.Mesh(waveGeo, waveMat);
                highQGroup.add(wave);
                anims.push({ type: 'highQCirculating', obj: wave, progress: i / 60 });
            }
            
            // === PARAMETER DISPLAY (Like reference image - left side) ===
            // Create info boxes showing Q-factor parameters
            const parameterLabels = [
                { text: 'Q-PARAMETERS', y: 12 },
                { text: '>1000', y: 8 },
                { text: 'Reduced', y: 6 },
                { text: 'Enhanced', y: 4 },
                { text: 'Sharp', y: 2 },
                { text: 'Defect Immune', y: 0 }
            ];
            
            // === KEY BENEFITS (Right side) ===
            const benefitLabels = [
                { text: 'Edge Confinement', y: 12 },
                { text: 'No Backscatter', y: 10 },
                { text: 'Corner Routing', y: 8 },
                { text: 'Energy Retention', y: 6 },
                { text: 'Sharp Passband', y: 4 },
                { text: 'Low Loss', y: 2 }
            ];
        }
        
        function build6G() {
            const group = currentGroup;
            
            // === REALISTIC CELL TOWER STRUCTURE ===
            // Tower base foundation
            const towerBase = new THREE.Mesh(
                new THREE.CylinderGeometry(8, 10, 8, 8),
                new THREE.MeshPhysicalMaterial({
                    color: 0x4a5568,
                    roughness: 0.4,
                    metalness: 0.8
                })
            );
            towerBase.position.y = -26;
            towerBase.castShadow = true;
            group.add(towerBase);
            
            // Tower main structure (tapered lattice)
            const towerSections = 6;
            for (let i = 0; i < towerSections; i++) {
                const sectionHeight = 12;
                const topRadius = 5 - i * 0.6;
                const bottomRadius = 5.5 - i * 0.6;
                
                const towerSection = new THREE.Mesh(
                    new THREE.CylinderGeometry(topRadius, bottomRadius, sectionHeight, 4),
                    new THREE.MeshPhysicalMaterial({
                        color: 0x6b7280,
                        roughness: 0.35,
                        metalness: 0.85,
                        wireframe: false
                    })
                );
                towerSection.position.y = -20 + i * sectionHeight;
                towerSection.castShadow = true;
                group.add(towerSection);
                
                // Cross bracing
                for (let j = 0; j < 4; j++) {
                    const angle = (j / 4) * Math.PI * 2;
                    const brace = new THREE.Mesh(
                        new THREE.BoxGeometry(0.4, sectionHeight * 1.4, 0.4),
                        materials.aluminum()
                    );
                    brace.position.set(
                        Math.cos(angle) * (bottomRadius + topRadius) / 2,
                        -20 + i * sectionHeight,
                        Math.sin(angle) * (bottomRadius + topRadius) / 2
                    );
                    brace.rotation.y = angle;
                    brace.rotation.z = Math.PI / 8;
                    group.add(brace);
                }
            }
            
            // === MASSIVE MIMO ANTENNA PANELS (Realistic 6G arrays) ===
            const antennaLevels = [25, 35, 45]; // Three height levels
            
            antennaLevels.forEach((height, levelIdx) => {
                for (let i = 0; i < 3; i++) {
                    const angle = (i / 3) * Math.PI * 2;
                    
                    // Main antenna panel
                    const panelGeo = new THREE.BoxGeometry(8, 18, 1.5);
                    const panelMat = new THREE.MeshPhysicalMaterial({
                        color: 0x2d3748,
                        roughness: 0.25,
                        metalness: 0.9,
                        clearcoat: 0.5
                    });
                    const panel = new THREE.Mesh(panelGeo, panelMat);
                    panel.position.set(
                        Math.cos(angle) * 6,
                        height,
                        Math.sin(angle) * 6
                    );
                    panel.rotation.y = -angle + Math.PI / 2;
                    panel.castShadow = true;
                    group.add(panel);
                    
                    // Antenna elements (64 elements per panel)
                    for (let row = 0; row < 8; row++) {
                        for (let col = 0; col < 8; col++) {
                            const elemGeo = new THREE.BoxGeometry(0.6, 0.6, 0.3);
                            const elemMat = new THREE.MeshStandardMaterial({
                                color: 0x8b5cf6,
                                emissive: 0x8b5cf6,
                                emissiveIntensity: 0.3,
                                roughness: 0.3,
                                metalness: 0.8
                            });
                            const elem = new THREE.Mesh(elemGeo, elemMat);
                            elem.position.set(
                                Math.cos(angle) * 6.8,
                                height - 7 + row * 1.8,
                                Math.sin(angle) * 6.8
                            );
                            
                            const offsetAngle = -angle + Math.PI / 2;
                            elem.position.x += Math.cos(offsetAngle) * (-3.5 + col * 1);
                            elem.position.z += Math.sin(offsetAngle) * (-3.5 + col * 1);
                            elem.rotation.y = -angle + Math.PI / 2;
                            
                            group.add(elem);
                            anims.push({ type: '6gAntennaElem', obj: elem, i: levelIdx * 24 + i * 8 + row });
                        }
                    }
                }
            });
            
            addLabel({ position: { x: 0, y: 50, z: 0 } }, '6G Base Station', 'Massive MIMO (192 elements)', {y: 5});
            
            // === SIGNAL BEAMS (Beamforming visualization) ===
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2;
                const beam = new THREE.Mesh(
                    new THREE.ConeGeometry(18, 55, 6, 1, true),
                    new THREE.MeshBasicMaterial({
                        color: i % 3 === 0 ? 0x3b82f6 : (i % 3 === 1 ? 0x8b5cf6 : 0xef4444),
                        transparent: true,
                        opacity: 0.08,
                        side: THREE.DoubleSide
                    })
                );
                beam.position.set(
                    Math.cos(angle) * 32,
                    15,
                    Math.sin(angle) * 32
                );
                beam.rotation.z = Math.PI / 2;
                beam.rotation.y = angle;
                group.add(beam);
            }
            
            // === CONNECTED DEVICES (Realistic models) ===
            const devices = [
                { pos: [55, -18, 0], type: 'phone', color: 0x3b82f6, label: 'Smartphone', desc: '1 Tbps peak' },
                { pos: [-50, -18, 35], type: 'car', color: 0x22c55e, label: 'Autonomous Car', desc: 'V2X comms' },
                { pos: [30, 5, -50], type: 'drone', color: 0xef4444, label: 'Drone', desc: '<1ms latency' },
                { pos: [-40, -18, -40], type: 'iot', color: 0xf59e0b, label: 'IoT Sensor', desc: 'Low power' }
            ];
            
            devices.forEach((dev, idx) => {
                let deviceMesh;
                
                if (dev.type === 'car') {
                    // Car body
                    const carBody = new THREE.Mesh(
                        new THREE.BoxGeometry(10, 4, 16),
                        new THREE.MeshPhysicalMaterial({
                            color: dev.color,
                            roughness: 0.2,
                            metalness: 0.8,
                            clearcoat: 0.9
                        })
                    );
                    carBody.position.set(...dev.pos);
                    group.add(carBody);
                    deviceMesh = carBody;
                    
                    // Wheels
                    for (let i = 0; i < 4; i++) {
                        const wheel = new THREE.Mesh(
                            new THREE.CylinderGeometry(2, 2, 1.5, 16),
                            materials.aluminum()
                        );
                        wheel.rotation.z = Math.PI / 2;
                        wheel.position.set(
                            dev.pos[0] + (i < 2 ? -4 : 4),
                            dev.pos[1] - 2,
                            dev.pos[2] + (i % 2 === 0 ? 5 : -5)
                        );
                        group.add(wheel);
                    }
                } else if (dev.type === 'drone') {
                    // Drone body
                    const droneBody = new THREE.Mesh(
                        new THREE.BoxGeometry(3, 1.5, 3),
                        new THREE.MeshPhysicalMaterial({
                            color: dev.color,
                            roughness: 0.3,
                            metalness: 0.7
                        })
                    );
                    droneBody.position.set(...dev.pos);
                    group.add(droneBody);
                    deviceMesh = droneBody;
                    
                    // Propellers
                    for (let i = 0; i < 4; i++) {
                        const propeller = new THREE.Mesh(
                            new THREE.TorusGeometry(2, 0.2, 8, 16),
                            materials.aluminum()
                        );
                        propeller.position.set(
                            dev.pos[0] + (i < 2 ? -3 : 3),
                            dev.pos[1],
                            dev.pos[2] + (i % 2 === 0 ? 3 : -3)
                        );
                        propeller.rotation.x = Math.PI / 2;
                        group.add(propeller);
                        anims.push({ type: 'droneProp', obj: propeller, i });
                    }
                } else if (dev.type === 'phone') {
                    deviceMesh = new THREE.Mesh(
                        new THREE.BoxGeometry(3, 6, 0.5),
                        new THREE.MeshPhysicalMaterial({
                            color: dev.color,
                            roughness: 0.1,
                            metalness: 0.9,
                            clearcoat: 1.0
                        })
                    );
                    deviceMesh.position.set(...dev.pos);
                    group.add(deviceMesh);
                } else {
                    deviceMesh = new THREE.Mesh(
                        new THREE.BoxGeometry(4, 4, 4),
                        new THREE.MeshPhysicalMaterial({
                            color: dev.color,
                            roughness: 0.4,
                            metalness: 0.6
                        })
                    );
                    deviceMesh.position.set(...dev.pos);
                    group.add(deviceMesh);
                }
                
                addLabel(deviceMesh, dev.label, dev.desc, {y: 8});
                
                // Data stream particles
                for (let i = 0; i < 8; i++) {
                    const particle = new THREE.Mesh(
                        new THREE.SphereGeometry(0.6, 12, 12),
                        new THREE.MeshStandardMaterial({
                            color: dev.color,
                            emissive: dev.color,
                            emissiveIntensity: 0.8,
                            transparent: true,
                            opacity: 0.85
                        })
                    );
                    group.add(particle);
                    anims.push({
                        type: '6gDataParticle',
                        obj: particle,
                        start: [0, 35, 0],
                        end: dev.pos,
                        offset: idx * 0.25 + i / 8
                    });
                }
            });
            
            // === SPECTRUM DISPLAY ===
            const spectrumY = 55;
            const spectrumBg = new THREE.Mesh(
                new THREE.BoxGeometry(80, 6, 2),
                new THREE.MeshPhysicalMaterial({
                    color: 0x1f2937,
                    roughness: 0.3,
                    metalness: 0.8
                })
            );
            spectrumBg.position.set(0, spectrumY, 0);
            group.add(spectrumBg);
            addLabel(spectrumBg, 'Spectrum Bands', 'Sub-6GHz / cmWave / mmWave', {y: 5});
            
            const bands = [
                { name: 'Sub-6 GHz', width: 22, color: 0x3b82f6, pos: -28 },
                { name: 'cmWave (7-24GHz)', width: 26, color: 0x8b5cf6, pos: -1 },
                { name: 'mmWave (>24GHz)', width: 22, color: 0xef4444, pos: 27 }
            ];
            
            bands.forEach(band => {
                const bandMesh = new THREE.Mesh(
                    new THREE.BoxGeometry(band.width, 4, 1.5),
                    new THREE.MeshPhysicalMaterial({
                        color: band.color,
                        emissive: band.color,
                        emissiveIntensity: 0.4,
                        roughness: 0.2,
                        metalness: 0.8,
                        clearcoat: 0.6
                    })
                );
                bandMesh.position.set(band.pos, spectrumY, 1.5);
                group.add(bandMesh);
                anims.push({ type: 'spectrumBand', obj: bandMesh });
            });
        }
        
        function buildQuantum() {
            const group = currentGroup;
            
            // === DILUTION REFRIGERATOR (Realistic multi-stage structure) ===
            // Outer vacuum chamber
            const vacuumChamber = new THREE.Mesh(
                new THREE.CylinderGeometry(38, 38, 85, 32, 1, true),
                new THREE.MeshPhysicalMaterial({
                    color: 0xd4d4d4,
                    transparent: true,
                    opacity: 0.15,
                    side: THREE.DoubleSide,
                    roughness: 0.2,
                    metalness: 0.9,
                    clearcoat: 0.8
                })
            );
            vacuumChamber.castShadow = true;
            group.add(vacuumChamber);
            addLabel(vacuumChamber, 'Dilution Refrigerator', 'Multi-stage cooling', {y: 45});
            
            // Mounting flange (top)
            const topFlange = new THREE.Mesh(
                new THREE.CylinderGeometry(40, 38, 3, 32),
                new THREE.MeshPhysicalMaterial({
                    color: 0x9ca3af,
                    roughness: 0.3,
                    metalness: 0.9
                })
            );
            topFlange.position.y = 44;
            topFlange.castShadow = true;
            group.add(topFlange);
            
            // Base plate
            const basePlate = new THREE.Mesh(
                new THREE.CylinderGeometry(42, 45, 6, 32),
                new THREE.MeshPhysicalMaterial({
                    color: 0x6b7280,
                    roughness: 0.35,
                    metalness: 0.85
                })
            );
            basePlate.position.y = -45;
            basePlate.castShadow = true;
            group.add(basePlate);
            
            // === COPPER COOLING STAGES (Realistic thermal stages) ===
            const coolingStages = [
                { temp: '4K', y: 25, radius: 28, color: 0xd97706, label: '4K Stage' },
                { temp: '1K', y: 10, radius: 24, color: 0xea580c, label: '1K Stage' },
                { temp: '100mK', y: -5, radius: 20, color: 0xf97316, label: '100mK Stage' },
                { temp: '20mK', y: -20, radius: 16, color: 0xfb923c, label: '20mK Stage' },
                { temp: '10mK', y: -32, radius: 12, color: 0xfdba74, label: 'Mixing Chamber' }
            ];
            
            coolingStages.forEach((stage, idx) => {
                // Copper thermal shield
                const shield = new THREE.Mesh(
                    new THREE.CylinderGeometry(stage.radius, stage.radius + 1, 4, 32),
                    new THREE.MeshPhysicalMaterial({
                        color: stage.color,
                        roughness: 0.25,
                        metalness: 0.95,
                        clearcoat: 0.7,
                        emissive: stage.color,
                        emissiveIntensity: 0.1
                    })
                );
                shield.position.y = stage.y;
                shield.castShadow = true;
                group.add(shield);
                anims.push({ type: 'coolingStage', obj: shield, stageIdx: idx });
                
                if (idx === coolingStages.length - 1) {
                    addLabel(shield, stage.label, stage.temp + ' - Qubits here', {y: -4});
                }
                
                // Thermal connection posts
                for (let i = 0; i < 4; i++) {
                    const angle = (i / 4) * Math.PI * 2;
                    const post = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.6, 0.6, idx < coolingStages.length - 1 ? 12 : 8, 12),
                        materials.copper()
                    );
                    post.position.set(
                        Math.cos(angle) * stage.radius * 0.7,
                        stage.y - (idx < coolingStages.length - 1 ? 8 : 6),
                        Math.sin(angle) * stage.radius * 0.7
                    );
                    group.add(post);
                }
            });
            
            // === QUANTUM CHIP AND QUBITS ===
            // Sapphire chip substrate
            const chipSubstrate = new THREE.Mesh(
                new THREE.BoxGeometry(18, 1.5, 18),
                new THREE.MeshPhysicalMaterial({
                    color: 0x1e3a5f,
                    roughness: 0.1,
                    metalness: 0.95,
                    clearcoat: 0.9
                })
            );
            chipSubstrate.position.y = -34;
            chipSubstrate.castShadow = true;
            group.add(chipSubstrate);
            addLabel(chipSubstrate, 'Superconducting Chip', 'Transmon qubits', {y: 3});
            
            // Transmon qubits (aluminum on sapphire)
            for (let i = 0; i < 5; i++) {
                const angle = (i / 5) * Math.PI * 2;
                const qubitGeo = new THREE.BoxGeometry(3, 1, 3);
                const qubitMat = new THREE.MeshPhysicalMaterial({
                    color: 0x8b5cf6,
                    emissive: 0x8b5cf6,
                    emissiveIntensity: 0.6,
                    roughness: 0.2,
                    metalness: 0.85,
                    clearcoat: 0.6
                });
                const qubit = new THREE.Mesh(qubitGeo, qubitMat);
                qubit.position.set(
                    Math.cos(angle) * 6,
                    -33,
                    Math.sin(angle) * 6
                );
                qubit.rotation.y = angle;
                group.add(qubit);
                anims.push({ type: 'quantumQubit', obj: qubit, qubitIdx: i });
                
                // Josephson junction (tiny cross)
                const junction = new THREE.Mesh(
                    new THREE.BoxGeometry(0.4, 0.8, 0.4),
                    new THREE.MeshStandardMaterial({
                        color: 0x3b82f6,
                        emissive: 0x3b82f6,
                        emissiveIntensity: 0.8
                    })
                );
                junction.position.set(
                    Math.cos(angle) * 6,
                    -32.5,
                    Math.sin(angle) * 6
                );
                group.add(junction);
            }
            
            // === TOPOLOGICAL PHONONIC WAVEGUIDE (Gold ring) ===
            const topoWaveguideGeo = new THREE.TorusGeometry(8, 1.2, 24, 64);
            const topoWaveguideMat = new THREE.MeshPhysicalMaterial({
                color: 0xfcd34d,
                roughness: 0.15,
                metalness: 0.95,
                clearcoat: 0.8,
                emissive: 0xfcd34d,
                emissiveIntensity: 0.35
            });
            const topoWaveguide = new THREE.Mesh(topoWaveguideGeo, topoWaveguideMat);
            topoWaveguide.position.y = -34;
            topoWaveguide.rotation.x = Math.PI / 2;
            topoWaveguide.castShadow = true;
            group.add(topoWaveguide);
            anims.push({ type: 'quantumWaveguide', obj: topoWaveguide });
            addLabel(topoWaveguide, 'Phononic Ring', 'Topological protection', {y: 3});
            
            // === PIEZOELECTRIC TRANSDUCERS (IDTs for phonon generation) ===
            for (let i = 0; i < 5; i++) {
                const angle = (i / 5) * Math.PI * 2 + Math.PI / 10;
                const transducerGeo = new THREE.CylinderGeometry(1.5, 1.5, 1.5, 16);
                const transducerMat = new THREE.MeshPhysicalMaterial({
                    color: 0x22c55e,
                    emissive: 0x22c55e,
                    emissiveIntensity: 0.45,
                    roughness: 0.25,
                    metalness: 0.85
                });
                const transducer = new THREE.Mesh(transducerGeo, transducerMat);
                transducer.position.set(
                    Math.cos(angle) * 8,
                    -34,
                    Math.sin(angle) * 8
                );
                transducer.castShadow = true;
                group.add(transducer);
                anims.push({ type: 'quantumTransducer', obj: transducer, i });
            }
            
            // === PHONON PARTICLES (State transfer visualization) ===
            for (let i = 0; i < 25; i++) {
                const phononGeo = new THREE.SphereGeometry(0.5, 16, 16);
                const phononMat = new THREE.MeshStandardMaterial({
                    color: 0xfcd34d,
                    emissive: 0xfcd34d,
                    emissiveIntensity: 1.0,
                    transparent: true,
                    opacity: 0.9
                });
                const phonon = new THREE.Mesh(phononGeo, phononMat);
                group.add(phonon);
                anims.push({ type: 'quantumPhonon', obj: phonon, progress: i / 25 });
            }
            
            // === COPPER MICROWAVE COAXIAL LINES ===
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                const coaxGeo = new THREE.CylinderGeometry(0.8, 0.8, 45, 16);
                const coaxMat = new THREE.MeshPhysicalMaterial({
                    color: 0xd97706,
                    roughness: 0.3,
                    metalness: 0.9
                });
                const coax = new THREE.Mesh(coaxGeo, coaxMat);
                coax.position.set(
                    Math.cos(angle) * 32,
                    10,
                    Math.sin(angle) * 32
                );
                coax.rotation.z = Math.PI / 6;
                coax.rotation.y = -angle;
                coax.castShadow = true;
                group.add(coax);
            }
            
            // === CONTROL/READOUT ELECTRONICS (Top assembly) ===
            const electronicsBox = new THREE.Mesh(
                new THREE.BoxGeometry(30, 8, 30),
                new THREE.MeshPhysicalMaterial({
                    color: 0x374151,
                    roughness: 0.4,
                    metalness: 0.8
                })
            );
            electronicsBox.position.y = 50;
            electronicsBox.castShadow = true;
            group.add(electronicsBox);
            addLabel(electronicsBox, 'Control Electronics', 'Readout & drive', {y: 6});
        }
        
        function animate() {
            requestAnimationFrame(animate);
            const t = Date.now() * 0.001;
            
            // Update process step highlighting
            const stepCount = stages[currentIndex].process.length;
            const activeStep = Math.floor((t * 0.5) % stepCount);
            for (let i = 0; i < stepCount; i++) {
                const stepEl = document.getElementById(`step-${i}`);
                if (stepEl) {
                    stepEl.classList.toggle('active', i === activeStep);
                }
            }
            
            anims.forEach(a => {
                switch(a.type) {
                    case 'light':
                        const lr = 100;
                        const la = t * 0.12 + a.i * Math.PI * 0.66;
                        a.obj.position.set(Math.cos(la) * lr, 60 + Math.sin(t * 0.4 + a.i) * 15, Math.sin(la) * lr);
                        a.obj.intensity = 1.5 + Math.sin(t * 1.5 + a.i) * 0.3;
                        break;
                        
                    case 'phone':
                        a.obj.rotation.y = Math.sin(t * 0.3) * 0.08;
                        break;
                        
                    case 'antenna':
                        a.obj.material.emissiveIntensity = 0.2 + Math.sin(t * 3 + a.i * 0.8) * 0.15;
                        break;
                        
                    case 'routerLED':
                        // Router LED status lights blinking
                        const ledPattern = a.idx < 2 ? 
                            0.8 + Math.sin(t * 4 + a.idx * 0.5) * 0.2 : // Green LEDs (power/wan) - steady with slight pulse
                            (a.idx < 4 ? 
                                0.6 + Math.sin(t * 8 + a.idx * 1.2) * 0.4 : // Blue LEDs (wifi bands) - faster blink
                                0.5 + Math.sin(t * 3) * 0.5); // Amber LED (activity) - medium blink
                        a.obj.material.emissiveIntensity = ledPattern;
                        break;
                        
                    case 'filter':
                        a.obj.material.emissiveIntensity = 0.15 + Math.sin(t * 4 + a.i) * 0.1;
                        break;
                        
                    case 'towerWave':
                        const twScale = 1 + Math.sin(t * 2 - a.i * 0.25) * 0.08;
                        a.obj.scale.setScalar(twScale);
                        a.obj.material.opacity = (0.6 - a.i * 0.04) * (0.5 + Math.sin(t * 2 - a.i * 0.25) * 0.5);
                        break;
                        
                    case 'routerWave':
                        const rwScale = 1 + Math.sin(t * 2.5 - a.i * 0.3) * 0.08;
                        a.obj.scale.setScalar(rwScale);
                        a.obj.material.opacity = (0.6 - a.i * 0.06) * (0.5 + Math.sin(t * 2.5 - a.i * 0.3) * 0.5);
                        break;
                        
                    case 'signalParticle':
                        const sp = (t * 0.25 + a.offset) % 1;
                        a.obj.position.set(
                            a.source[0] + (a.target[0] - a.source[0]) * sp,
                            a.source[1] + (a.target[1] - a.source[1]) * sp,
                            a.source[2] + (a.target[2] - a.source[2]) * sp
                        );
                        break;
                        
                    case 'rfSignal':
                        const rp = (t * 0.3 + a.offset) % 1;
                        const antPos = [
                            [8, 18, 0], [-8, 18, 0], [8, -18, 0], 
                            [-8, -18, 0], [9.5, 5, 0], [-9.5, 5, 0]
                        ][a.antIdx];
                        const targetPos = [-4, -5, 0];
                        a.obj.position.set(
                            antPos[0] + (targetPos[0] - antPos[0]) * rp,
                            antPos[1] + (targetPos[1] - antPos[1]) * rp,
                            antPos[2] + (targetPos[2] - antPos[2]) * rp
                        );
                        break;
                        
                    case 'idtFinger':
                        a.obj.material.emissiveIntensity = Math.sin(t * 6 + a.i * 0.4) * 0.15 + 0.15;
                        break;
                        
                    case 'sawWaveLine':
                        // Animate wave lines by updating material
                        a.obj.material.opacity = 0.4 + Math.sin(t * 3 + a.offset * 10) * 0.4;
                        break;
                        
                    case 'waveMarker':
                        const wmp = (t * 0.35 + a.offset) % 1;
                        const waveX = -35 + wmp * 80;
                        a.obj.position.set(
                            waveX,
                            -6.5 + Math.sin(wmp * Math.PI * 8) * 2,
                            Math.sin(wmp * Math.PI * 4) * 5
                        );
                        break;
                        
                    case 'trivialInclusion':
                    case 'nontrivialInclusion':
                        a.obj.material.emissiveIntensity = 0.1 + Math.sin(t * 2.5 + a.i * 0.15) * 0.08;
                        break;
                        
                    case 'interface':
                        a.obj.material.emissiveIntensity = 0.4 + Math.sin(t * 4) * 0.2;
                        break;
                        
                    case 'edgeState':
                        const ep = (t * 0.3 + a.offset) % 1;
                        a.obj.position.set(
                            Math.sin(ep * Math.PI * 4) * 2,
                            -8,
                            -22 + ep * 44
                        );
                        break;
                        
                    case 'inputWave':
                        const ip = (t * 0.3 + a.offset) % 1;
                        a.obj.position.set(0, -8, -32 + ip * 30);
                        break;
                        
                    case 'f1Wave':
                        const f1p = (t * 0.28 + a.offset + 0.4) % 1;
                        if (f1p < 0.5) {
                            a.obj.position.set(-10, -8, -2 + f1p * 68);
                        } else {
                            a.obj.position.set(-10 - (f1p - 0.5) * 30, -8, 32);
                        }
                        break;
                        
                    case 'f2Wave':
                        const f2p = (t * 0.28 + a.offset + 0.6) % 1;
                        if (f2p < 0.5) {
                            a.obj.position.set(10, -8, -2 + f2p * 68);
                        } else {
                            a.obj.position.set(10 + (f2p - 0.5) * 30, -8, 32);
                        }
                        break;
                        
                    case 'qParticle':
                        const qp = (t * 0.4 + a.i * 0.15) % 1;
                        a.obj.position.set(
                            -30 + qp * 60,
                            10 + Math.sin(qp * Math.PI * 3) * 3,
                            -5
                        );
                        break;
                        
                    case 'defect':
                        a.obj.material.opacity = 0.25 + Math.sin(t * 3) * 0.15;
                        break;
                        
                    case '6gAntenna':
                        a.obj.material.emissiveIntensity = 0.2 + Math.sin(t * 2.5 + a.i * 0.5) * 0.15;
                        break;
                        
                    case '6gData':
                        const dp = (t * 0.35 + a.offset) % 1;
                        a.obj.position.set(
                            a.start[0] + (a.end[0] - a.start[0]) * dp,
                            a.start[1] + (a.end[1] - a.start[1]) * dp,
                            a.start[2] + (a.end[2] - a.start[2]) * dp
                        );
                        break;
                        
                    case 'qubit':
                        a.obj.material.emissiveIntensity = 0.35 + Math.sin(t * 3 + a.i * Math.PI / 2) * 0.25;
                        break;
                        
                    case 'waveguide':
                        a.obj.material.emissiveIntensity = 0.3 + Math.sin(t * 2) * 0.15;
                        break;
                        
                    case 'phonon':
                        const pp = (t * 0.4 + a.offset) % 1;
                        const pAngle = pp * Math.PI * 2;
                        a.obj.position.set(
                            Math.cos(pAngle) * 10,
                            -6,
                            Math.sin(pAngle) * 10
                        );
                        break;
                        
                    case 'stateArrow':
                        a.obj.rotation.x = Math.sin(t * 0.4) * 0.6;
                        a.obj.rotation.z = Math.cos(t * 0.25) * 0.6;
                        break;
                        
                    case 'rfParticle':
                        a.obj.position.add(a.obj.userData.velocity);
                        // Bounce off boundaries
                        if (Math.abs(a.obj.position.x) > 30) a.obj.userData.velocity.x *= -1;
                        if (Math.abs(a.obj.position.y) > 20) a.obj.userData.velocity.y *= -1;
                        if (Math.abs(a.obj.position.z) > 30) a.obj.userData.velocity.z *= -1;
                        break;
                        
                    case 'sineWave':
                        // Animate sine wave expanding and pulsing
                        const swScale = 1 + Math.sin(t * 2 - a.i * 0.25) * 0.08;
                        a.obj.scale.setScalar(swScale);
                        a.obj.material.opacity = (0.7 - a.i * 0.05) * (0.5 + Math.sin(t * 2 - a.i * 0.25) * 0.5);
                        a.obj.material.emissiveIntensity = 0.6 + Math.sin(t * 3 - a.i * 0.3) * 0.3;
                        break;
                        
                    case 'cosineWave':
                        // Animate cosine wave expanding and pulsing
                        const cwScale = 1 + Math.sin(t * 2 - a.i * 0.25) * 0.08;
                        a.obj.scale.setScalar(cwScale);
                        a.obj.material.opacity = (0.7 - a.i * 0.05) * (0.5 + Math.sin(t * 2 - a.i * 0.25) * 0.5);
                        a.obj.material.emissiveIntensity = 0.6 + Math.cos(t * 3 - a.i * 0.3) * 0.3;
                        break;
                        
                    case 'idtFingerRF':
                        // Piezoelectric vibration in SAW filter
                        const vibration = Math.sin(t * 20 + a.i * 0.5) * 0.05;
                        a.obj.position.y = 1.08 + vibration;
                        a.obj.material.emissiveIntensity = 0.1 + Math.abs(vibration) * 2;
                        break;
                        
                    case 'pcPillarRF':
                        // Phononic resonance in SAW filter
                        const resonance = Math.sin(t * 8 + a.i * 0.3 + a.j * 0.3) * 0.1;
                        a.obj.scale.y = 1 + resonance;
                        a.obj.material.emissiveIntensity = 0.2 + resonance * 0.5;
                        break;
                        
                    case 'topoInterfaceRF':
                        // Edge state glow in SAW filter
                        a.obj.material.emissiveIntensity = 0.4 + Math.sin(t * 4) * 0.2;
                        break;
                        
                    case 'sawWaveRF':
                        // SAW propagation through device
                        a.progress += 0.004;
                        if (a.progress > 1) a.progress = 0;
                        
                        const sawX = -35 + a.progress * 70;
                        const sawY = 1.5 + Math.sin(a.progress * Math.PI * 20 + t * 10) * 0.3;
                        const sawZ = (a.lane - 2) * 2;
                        
                        a.obj.position.set(sawX, sawY, sawZ);
                        
                        // Intensity changes through phononic crystal
                        let intensity = 0.8;
                        if (sawX > -10 && sawX < 10) {
                            // Filtering in phononic crystal region
                            intensity = 0.4 + Math.sin(a.progress * Math.PI * 40) * 0.4;
                        }
                        a.obj.material.opacity = intensity;
                        break;
                        
                    // === NEW SMARTPHONE RF ANIMATIONS ===
                    case 'rfChipGlow':
                        // RF chip pulsing glow
                        if (!a.obj.material.emissive) {
                            a.obj.material.emissive = new THREE.Color(0x0ea5e9);
                        }
                        a.obj.material.emissiveIntensity = 0.3 + Math.sin(t * 3) * 0.2;
                        break;
                        
                    case 'sawFilterPulse':
                        // Individual SAW filters pulsing
                        a.obj.material.emissiveIntensity = 0.1 + Math.sin(t * 4 + a.idx * 0.5) * 0.15;
                        break;
                        
                    case 'rfSignalParticle':
                        // RF signal particles orbiting phone
                        const angle = a.startAngle + t * a.speed;
                        const radius = a.radius;
                        a.obj.position.set(
                            Math.cos(angle) * radius,
                            a.height,
                            Math.sin(angle) * radius
                        );
                        a.obj.material.emissiveIntensity = 0.6 + Math.sin(t * 5 + angle) * 0.3;
                        break;
                        
                    case 'phoneRFWave':
                        // RF waves expanding from phone
                        const waveScale = 1 + Math.sin(t * 2 - a.idx * 0.3) * 0.1;
                        a.obj.scale.setScalar(waveScale);
                        a.obj.material.opacity = (0.6 - a.idx * 0.04) * (0.5 + Math.sin(t * 2 - a.idx * 0.25) * 0.5);
                        a.obj.rotation.z = t * 0.5;
                        break;
                        
                    // === NEW SAW FILTER DEVICE ANIMATIONS ===
                    case 'idtFingerFilter':
                        // Piezoelectric vibration in SAW filter device
                        const vibFilter = Math.sin(t * 20 + a.i * 0.5) * 0.05;
                        a.obj.position.y = 1.08 + vibFilter;
                        a.obj.material.emissiveIntensity = 0.1 + Math.abs(vibFilter) * 2;
                        break;
                        
                    case 'pcPillarFilter':
                        // Phononic resonance in SAW filter device
                        const resFilter = Math.sin(t * 8 + a.i * 0.3 + a.j * 0.3) * 0.1;
                        a.obj.scale.y = 1 + resFilter;
                        a.obj.material.emissiveIntensity = 0.2 + resFilter * 0.5;
                        break;
                        
                    case 'topoInterfaceFilter':
                        // Edge state glow in SAW filter device
                        a.obj.material.emissiveIntensity = 0.5 + Math.sin(t * 4) * 0.2;
                        break;
                        
                    case 'sawWaveFilter':
                        // SAW propagation through filter device
                        a.progress += 0.004;
                        if (a.progress > 1) a.progress = 0;
                        
                        const filterX = -35 + a.progress * 70;
                        const filterY = 1.5 + Math.sin(a.progress * Math.PI * 20 + t * 10) * 0.3;
                        const filterZ = (a.lane - 2) * 2;
                        
                        a.obj.position.set(filterX, filterY, filterZ);
                        
                        // Intensity changes through phononic crystal
                        let filterIntensity = 0.8;
                        if (filterX > -10 && filterX < 10) {
                            // Filtering in phononic crystal region
                            filterIntensity = 0.4 + Math.sin(a.progress * Math.PI * 40) * 0.4;
                        }
                        a.obj.material.opacity = filterIntensity;
                        break;
                        
                    // === SAW OPERATION VIEW ANIMATIONS ===
                    case 'idtFingerOperation':
                        // Enhanced piezoelectric vibration
                        const vibOp = Math.sin(t * 20 + a.i * 0.5) * 0.06;
                        a.obj.position.y = 1.08 + vibOp;
                        a.obj.material.emissiveIntensity = 0.15 + Math.abs(vibOp) * 3;
                        break;
                        
                    case 'pcPillarOperation':
                        // Enhanced phononic resonance
                        const resOp = Math.sin(t * 8 + a.i * 0.3 + a.j * 0.3) * 0.12;
                        a.obj.scale.y = 1 + resOp;
                        a.obj.material.emissiveIntensity = 0.3 + resOp * 0.6;
                        break;
                        
                    case 'topoInterfaceOperation':
                        // Enhanced edge state glow
                        a.obj.material.emissiveIntensity = 0.6 + Math.sin(t * 4) * 0.3;
                        break;
                        
                    case 'sawWaveOperation':
                        // Enhanced SAW propagation visualization
                        a.progress += 0.005;
                        if (a.progress > 1) a.progress = 0;
                        
                        const opX = -35 + a.progress * 70;
                        const opY = 1.5 + Math.sin(a.progress * Math.PI * 18 + t * 10) * 0.4;
                        const opZ = (a.lane - 3) * 2.5;
                        
                        a.obj.position.set(opX, opY, opZ);
                        
                        // More dramatic filtering effect
                        let opIntensity = 0.9;
                        if (opX > -10 && opX < 10) {
                            opIntensity = 0.3 + Math.sin(a.progress * Math.PI * 50) * 0.5;
                        }
                        a.obj.material.opacity = opIntensity;
                        a.obj.material.emissiveIntensity = 0.8 + opIntensity * 0.4;
                        break;
                        
                    // === TOPOLOGICAL PHONONIC CRYSTAL ANIMATIONS ===
                    case 'trivialPillar':
                        // Trivial domain pillars (small inclusions)
                        const trivScale = 1 + Math.sin(t * 6 + a.i * 0.4 + a.j * 0.4) * 0.08;
                        a.obj.scale.y = trivScale;
                        a.obj.material.emissiveIntensity = 0.15 + Math.abs(Math.sin(t * 6 + a.i * 0.4)) * 0.1;
                        break;
                        
                    case 'nontrivialPillar':
                        // Non-trivial domain pillars (large inclusions)
                        const nonTrivScale = 1 + Math.sin(t * 5 + a.i * 0.3 + a.j * 0.5) * 0.1;
                        a.obj.scale.y = nonTrivScale;
                        a.obj.material.emissiveIntensity = 0.15 + Math.abs(Math.sin(t * 5 + a.j * 0.3)) * 0.12;
                        break;
                        
                    case 'interfacePillar':
                        // Interface pillars with stronger glow
                        const intScale = 1 + Math.sin(t * 7 + a.i * 0.5 + a.j * 0.6) * 0.12;
                        a.obj.scale.y = intScale;
                        a.obj.material.emissiveIntensity = 0.35 + Math.sin(t * 4 + a.i * 0.4) * 0.25;
                        break;
                        
                    case 'topoWaveLeft':
                        // Waves from input IDT (bottom) entering the interface
                        a.progress += 0.007;
                        if (a.progress > 1) a.progress = 0;
                        
                        const leftX = -25 + a.pathOffset * 50; // Spread across x
                        const leftY = 1.2 + Math.sin(a.progress * Math.PI * 10 + t * 8) * 0.4;
                        const leftZ = -32 + a.progress * 29; // From input IDT toward interface
                        
                        a.obj.position.set(leftX, leftY, leftZ);
                        a.obj.material.opacity = 0.85 * (1 - a.progress * 0.4);
                        a.obj.material.emissiveIntensity = 0.9 + Math.sin(a.progress * Math.PI * 12) * 0.3;
                        break;
                        
                    case 'topoWaveRight':
                        // Waves from interface to output IDT (top)
                        a.progress += 0.007;
                        if (a.progress > 1) a.progress = 0;
                        
                        const rightX = -25 + a.pathOffset * 50; // Spread across x
                        const rightY = 1.2 + Math.sin(a.progress * Math.PI * 10 + t * 8) * 0.4;
                        const rightZ = 3 + a.progress * 29; // From interface to output IDT
                        
                        a.obj.position.set(rightX, rightY, rightZ);
                        a.obj.material.opacity = 0.85 * (1 - a.progress * 0.4);
                        a.obj.material.emissiveIntensity = 0.9 + Math.sin(a.progress * Math.PI * 12) * 0.3;
                        break;
                        
                    case 'edgeStateWave':
                        // Topologically protected edge states along HORIZONTAL interface (z=0)
                        a.progress += 0.01;
                        if (a.progress > 1) a.progress = 0;
                        
                        const edgeX = -60 + a.progress * 120; // Travel horizontally from left to right
                        const edgeY = 1.2 + Math.sin(a.progress * Math.PI * 20 + t * 12) * 0.35;
                        const edgeZ = 0 + a.lane * 1.2; // Stay near z=0 interface with slight variation
                        
                        a.obj.position.set(edgeX, edgeY, edgeZ);
                        a.obj.material.opacity = 0.92;
                        a.obj.material.emissiveIntensity = 1.1 + Math.sin(a.progress * Math.PI * 25) * 0.4;
                        
                        // Pulse scale
                        const edgeScale = 1 + Math.sin(a.progress * Math.PI * 15) * 0.35;
                        a.obj.scale.setScalar(edgeScale);
                        break;
                        
                    case 'edgeStateWaveSequential':
                        // Sequential transmission along centerline: Stage 1 (Input→Output along z=0), Stage 2 (Center→Left along x), Stage 3 (Center→Right along x)
                        const cycleDuration = 3.0; // 3 seconds per full cycle
                        const cycleTime = (t % (cycleDuration * 3));
                        
                        let seqX, seqY, seqZ, isVisible;
                        
                        if (a.stage === 1) {
                            // Stage 1: Input IDT (z=-32) to Output IDT (z=+32) - vertical transmission along x=0 centerline
                            const stage1Start = 0;
                            const stage1End = cycleDuration;
                            
                            if (cycleTime >= stage1Start && cycleTime < stage1End) {
                                const stageProgress = (cycleTime - stage1Start) / cycleDuration;
                                const localProgress = (a.progress + stageProgress) % 1;
                                
                                seqX = 0 + a.lane * 0.8; // Stay near x=0 centerline
                                seqZ = -32 + localProgress * 64; // -32 to +32 along topological interface
                                seqY = 1.2 + Math.sin(localProgress * Math.PI * 20 + t * 12) * 0.35;
                                isVisible = true;
                            } else {
                                isVisible = false;
                            }
                        } else if (a.stage === 2) {
                            // Stage 2: Center (x=0, z=0) to Left IDT (x=-58, z=0) - horizontal transmission along z=0 centerline
                            const stage2Start = cycleDuration;
                            const stage2End = cycleDuration * 2;
                            
                            if (cycleTime >= stage2Start && cycleTime < stage2End) {
                                const stageProgress = (cycleTime - stage2Start) / cycleDuration;
                                const localProgress = (a.progress + stageProgress) % 1;
                                
                                seqX = 0 - localProgress * 58; // 0 to -58 (center to left)
                                seqZ = 0 + a.lane * 0.8; // Stay near z=0 centerline
                                seqY = 1.2 + Math.sin(localProgress * Math.PI * 20 + t * 12) * 0.35;
                                isVisible = true;
                            } else {
                                isVisible = false;
                            }
                        } else if (a.stage === 3) {
                            // Stage 3: Center (x=0, z=0) to Right IDT (x=+58, z=0) - horizontal transmission along z=0 centerline
                            const stage3Start = cycleDuration * 2;
                            const stage3End = cycleDuration * 3;
                            
                            if (cycleTime >= stage3Start && cycleTime < stage3End) {
                                const stageProgress = (cycleTime - stage3Start) / cycleDuration;
                                const localProgress = (a.progress + stageProgress) % 1;
                                
                                seqX = 0 + localProgress * 58; // 0 to +58 (center to right)
                                seqZ = 0 + a.lane * 0.8; // Stay near z=0 centerline
                                seqY = 1.2 + Math.sin(localProgress * Math.PI * 20 + t * 12) * 0.35;
                                isVisible = true;
                            } else {
                                isVisible = false;
                            }
                        }
                        
                        if (isVisible) {
                            a.obj.position.set(seqX, seqY, seqZ);
                            a.obj.material.opacity = 0.92;
                            a.obj.material.emissiveIntensity = 1.1 + Math.sin(t * 8) * 0.4;
                            a.obj.visible = true;
                            
                            const seqScale = 1 + Math.sin(t * 15) * 0.35;
                            a.obj.scale.setScalar(seqScale);
                        } else {
                            a.obj.visible = false;
                        }
                        break;
                        
                    // === EDGE STATE PROPAGATION ANIMATIONS ===
                    case 'topologicalInterface':
                        // Pulsing topological interface line
                        a.obj.material.emissiveIntensity = 0.6 + Math.sin(t * 3.5) * 0.3;
                        break;
                        
                    case 'sourceGlow':
                        // Pulsing wave source
                        a.obj.material.emissiveIntensity = 0.7 + Math.sin(t * 4) * 0.3;
                        const sourceScale = 1 + Math.sin(t * 4) * 0.1;
                        a.obj.scale.setScalar(sourceScale);
                        break;
                        
                    case 'edgeWaveCardinal':
                        // Four-way propagation from center along cardinal axes (plus sign)
                        a.phase += a.speed * 0.012;
                        if (a.phase > Math.PI * 2) a.phase -= Math.PI * 2;
                        
                        const cardProgress = a.phase / (Math.PI * 2);
                        let cX, cY, cZ;
                        
                        // Waves propagate in straight lines along cardinal axes
                        if (a.direction === 'forward') {
                            // Forward along +Z axis
                            cX = 0;
                            cZ = cardProgress * 55;
                        } else if (a.direction === 'backward') {
                            // Backward along -Z axis
                            cX = 0;
                            cZ = -cardProgress * 55;
                        } else if (a.direction === 'right') {
                            // Right along +X axis
                            cX = cardProgress * 70;
                            cZ = 0;
                        } else if (a.direction === 'left') {
                            // Left along -X axis
                            cX = -cardProgress * 70;
                            cZ = 0;
                        }
                        
                        cY = 1.0 + Math.sin(t * 8 + a.phase * 10) * 0.25; // Wave oscillation
                        
                        a.obj.position.set(cX, cY, cZ);
                        a.obj.material.emissiveIntensity = 1.2 + Math.sin(t * 8 + a.phase) * 0.3;
                        break;
                        
                    case 'trailCardinal':
                        // Trail particles for cardinal direction paths
                        const trPhase = a.phase + t * 0.4;
                        const trProgress = (trPhase / (Math.PI * 2)) % 1;
                        let trX, trZ;
                        
                        if (a.direction === 'forward') {
                            trX = 0;
                            trZ = trProgress * 55;
                        } else if (a.direction === 'backward') {
                            trX = 0;
                            trZ = -trProgress * 55;
                        } else if (a.direction === 'right') {
                            trX = trProgress * 70;
                            trZ = 0;
                        } else if (a.direction === 'left') {
                            trX = -trProgress * 70;
                            trZ = 0;
                        }
                        
                        a.obj.position.set(trX, 1.0, trZ);
                        break;
                        
                    case 'arrowPulse':
                        // Pulsing directional arrows
                        const arrowScale = 1 + Math.sin(t * 3) * 0.15;
                        a.obj.scale.setScalar(arrowScale);
                        a.obj.material.opacity = 0.6 + Math.sin(t * 3) * 0.2;
                        break;
                        
                    case 'backscatterCardinal':
                        // Show attempted backscatter being suppressed near cardinal direction defects
                        const bsPhase = a.phase + t * 3;
                        const bsProgress = (bsPhase / (Math.PI * 2)) % 1;
                        
                        // Position near respective cardinal direction defect
                        let bsX, bsZ, bsBaseX, bsBaseZ;
                        
                        if (a.direction === 'forward') {
                            bsBaseX = 0; bsBaseZ = 30;
                        } else if (a.direction === 'backward') {
                            bsBaseX = 0; bsBaseZ = -30;
                        } else if (a.direction === 'right') {
                            bsBaseX = 40; bsBaseZ = 0;
                        } else if (a.direction === 'left') {
                            bsBaseX = -40; bsBaseZ = 0;
                        }
                        
                        // Oscillate around defect, trying to backscatter but failing
                        bsX = bsBaseX + Math.sin(bsPhase * 2) * 4;
                        bsZ = bsBaseZ + Math.cos(bsPhase * 2) * 4;
                        
                        a.obj.position.set(
                            bsX,
                            1.0 + Math.sin(bsPhase * 4) * 0.3,
                            bsZ
                        );
                        
                        // Fade out to show suppression
                        a.obj.material.opacity = 0.3 * (1 - bsProgress);
                        a.obj.scale.setScalar(0.5 + bsProgress * 0.3);
                        break;
                        
                    case 'textGlow':
                        // Pulsing text overlay
                        a.obj.material.opacity = 0.9 + Math.sin(t * 2.5) * 0.1;
                        break;
                    
                    // === DIRECTIONAL ROUTING ANIMATIONS ===
                    case 'routingInterface':
                        // Pulsing gold interface channels
                        a.obj.material.emissiveIntensity = 0.35 + Math.sin(t * 3 + (a.side === 'left' ? 0 : Math.PI)) * 0.15;
                        break;
                        
                    case 'routingPort':
                        // Port pulsing based on type
                        if (a.portType === 'input') {
                            a.obj.material.emissiveIntensity = 0.4 + Math.sin(t * 4) * 0.2;
                        } else if (a.portType === 'outputA') {
                            a.obj.material.emissiveIntensity = 0.45 + Math.sin(t * 3.5 + 0.3) * 0.25;
                        } else if (a.portType === 'outputB') {
                            a.obj.material.emissiveIntensity = 0.45 + Math.sin(t * 3.5 + 0.7) * 0.25;
                        }
                        break;
                        
                    case 'routingInputWave':
                        // Input waves traveling from input port upward
                        a.progress += 0.006;
                        if (a.progress > 1) a.progress = 0;
                        
                        const inX = 0;
                        const inY = 1.6 + Math.sin(a.progress * Math.PI * 10) * 0.4;
                        const inZ = -42 + a.progress * 22; // Travel to junction (z = -20)
                        
                        a.obj.position.set(inX, inY, inZ);
                        a.obj.material.opacity = 0.85 * (1 - a.progress * 0.2);
                        a.obj.material.emissiveIntensity = 0.9 + Math.sin(a.progress * Math.PI * 12) * 0.3;
                        break;
                        
                    case 'routingF1Wave':
                        // f1 waves routing to left Port A (orange path)
                        a.progress += 0.005;
                        if (a.progress > 1) a.progress = 0;
                        
                        let f1X, f1Y, f1Z;
                        
                        if (a.progress < 0.3) {
                            // Travel from junction to left interface
                            const t1 = a.progress / 0.3;
                            f1X = -13 * t1;
                            f1Y = 1.6;
                            f1Z = -20 + t1 * 10;
                        } else if (a.progress < 0.7) {
                            // Travel along left interface
                            const t2 = (a.progress - 0.3) / 0.4;
                            f1X = -13;
                            f1Y = 1.5 + Math.sin(t2 * Math.PI * 12) * 0.5;
                            f1Z = -10 + t2 * 40;
                        } else {
                            // Move to Port A
                            const t3 = (a.progress - 0.7) / 0.3;
                            f1X = -13 + (-32 + 13) * t3;
                            f1Y = 1.5 + 0.3 * t3;
                            f1Z = 30 + t3 * 12;
                        }
                        
                        a.obj.position.set(f1X, f1Y, f1Z);
                        a.obj.material.opacity = 0.9 * (1 - a.progress * 0.15);
                        a.obj.material.emissiveIntensity = 1.0 + Math.sin(a.progress * Math.PI * 15) * 0.4;
                        break;
                        
                    case 'routingF2Wave':
                        // f2 waves routing to right Port B (purple path)
                        a.progress += 0.005;
                        if (a.progress > 1) a.progress = 0;
                        
                        let f2X, f2Y, f2Z;
                        
                        if (a.progress < 0.3) {
                            // Travel from junction to right interface
                            const t1 = a.progress / 0.3;
                            f2X = 13 * t1;
                            f2Y = 1.6;
                            f2Z = -20 + t1 * 10;
                        } else if (a.progress < 0.7) {
                            // Travel along right interface
                            const t2 = (a.progress - 0.3) / 0.4;
                            f2X = 13;
                            f2Y = 1.5 + Math.sin(t2 * Math.PI * 12) * 0.5;
                            f2Z = -10 + t2 * 40;
                        } else {
                            // Move to Port B
                            const t3 = (a.progress - 0.7) / 0.3;
                            f2X = 13 + (32 - 13) * t3;
                            f2Y = 1.5 + 0.3 * t3;
                            f2Z = 30 + t3 * 12;
                        }
                        
                        a.obj.position.set(f2X, f2Y, f2Z);
                        a.obj.material.opacity = 0.9 * (1 - a.progress * 0.15);
                        a.obj.material.emissiveIntensity = 1.0 + Math.sin(a.progress * Math.PI * 15) * 0.4;
                        break;
                        
                    case 'cornerMarker':
                        // Corner navigation markers - pulsing
                        const cornerPulse = 0.6 + Math.sin(t * 4 + a.idx * 0.5) * 0.3;
                        a.obj.material.opacity = cornerPulse * 0.6;
                        a.obj.material.emissiveIntensity = cornerPulse;
                        a.obj.rotation.z = t * 0.5 + a.idx * Math.PI / 2;
                        break;
                        
                    // === HIGH-Q RESONATOR ANIMATIONS ===
                    case 'highQResonator':
                        // High-Q cavity pulsing
                        a.obj.material.emissiveIntensity = 0.4 + Math.sin(t * 2.5) * 0.15;
                        a.obj.rotation.z = t * 0.3;
                        break;
                        
                    case 'highQPillar':
                        // Phononic pillars resonating
                        const pillarPhase = Math.sin(t * 6 + a.row * 0.4 + a.col * 0.3);
                        a.obj.scale.y = 1 + pillarPhase * 0.12;
                        a.obj.material.emissiveIntensity = 0.15 + pillarPhase * 0.1;
                        break;
                        
                    case 'highQPort':
                        // Input/output port pulsing
                        const portIntensity = a.portType === 'input' ? 
                            0.45 + Math.sin(t * 3) * 0.2 :
                            0.45 + Math.sin(t * 3 + 0.5) * 0.2;
                        a.obj.material.emissiveIntensity = portIntensity;
                        break;
                        
                    case 'highQCirculating':
                        // Waves circulating in high-Q cavity
                        a.progress += 0.003; // Slow = high Q factor
                        if (a.progress > 1) a.progress = 0;
                        
                        const circAngle = a.progress * Math.PI * 2;
                        const circRadius = 18;
                        const circX = Math.cos(circAngle) * circRadius;
                        const circY = 2.2 + Math.sin(a.progress * Math.PI * 20) * 0.8;
                        const circZ = Math.sin(circAngle) * circRadius;
                        
                        a.obj.position.set(circX, circY, circZ);
                        a.obj.material.emissiveIntensity = 1.0 + Math.sin(a.progress * Math.PI * 30) * 0.4;
                        break;
                        
                    case 'highQDefect':
                        // Defect pulsing - waves pass without scattering
                        a.obj.material.emissiveIntensity = 0.3 + Math.sin(t * 3) * 0.2;
                        a.obj.rotation.y += 0.01;
                        break;
                        
                    // === 6G TOWER ANIMATIONS ===
                    case '6gAntennaElem':
                        // Antenna elements pulsing
                        a.obj.material.emissiveIntensity = 0.3 + Math.sin(t * 4 + a.i * 0.15) * 0.2;
                        break;
                        
                    case '6gDataParticle':
                        // Data particles traveling to devices
                        const dataProgress = (t * 0.3 + a.offset) % 1;
                        a.obj.position.set(
                            a.start[0] + (a.end[0] - a.start[0]) * dataProgress,
                            a.start[1] + (a.end[1] - a.start[1]) * dataProgress,
                            a.start[2] + (a.end[2] - a.start[2]) * dataProgress
                        );
                        a.obj.material.opacity = 0.85 * (1 - dataProgress * 0.3);
                        a.obj.material.emissiveIntensity = 0.8 + Math.sin(dataProgress * Math.PI * 10) * 0.3;
                        break;
                        
                    case 'droneProp':
                        // Drone propellers spinning
                        a.obj.rotation.z += 0.15;
                        break;
                        
                    case 'spectrumBand':
                        // Spectrum bands pulsing
                        a.obj.material.emissiveIntensity = 0.4 + Math.sin(t * 2.5) * 0.15;
                        break;
                        
                    // === QUANTUM COMPUTER ANIMATIONS ===
                    case 'coolingStage':
                        // Cooling stages subtle pulsing
                        const stagePulse = 0.1 + Math.sin(t * 1.5 + a.stageIdx * 0.4) * 0.05;
                        a.obj.material.emissiveIntensity = stagePulse;
                        break;
                        
                    case 'quantumQubit':
                        // Qubits oscillating in superposition
                        a.obj.material.emissiveIntensity = 0.6 + Math.sin(t * 8 + a.qubitIdx * 1.2) * 0.3;
                        const qubitScale = 1 + Math.sin(t * 8 + a.qubitIdx * 1.2) * 0.08;
                        a.obj.scale.setScalar(qubitScale);
                        break;
                        
                    case 'quantumWaveguide':
                        // Topological waveguide glowing
                        a.obj.material.emissiveIntensity = 0.35 + Math.sin(t * 2) * 0.15;
                        a.obj.rotation.z = t * 0.2;
                        break;
                        
                    case 'quantumTransducer':
                        // Piezoelectric transducers pulsing
                        a.obj.material.emissiveIntensity = 0.45 + Math.sin(t * 5 + a.i * 0.8) * 0.25;
                        break;
                        
                    case 'quantumPhonon':
                        // Phonons traveling in ring
                        a.progress += 0.006;
                        if (a.progress > 1) a.progress = 0;
                        
                        const phononAngle = a.progress * Math.PI * 2;
                        const phononRadius = 8;
                        const phononX = Math.cos(phononAngle) * phononRadius;
                        const phononY = -34 + Math.sin(a.progress * Math.PI * 15) * 0.6;
                        const phononZ = Math.sin(phononAngle) * phononRadius;
                        
                        a.obj.position.set(phononX, phononY, phononZ);
                        a.obj.material.emissiveIntensity = 1.0 + Math.sin(a.progress * Math.PI * 20) * 0.4;
                        break;
                }
            });
            
            // Camera movement
            const camRadius = currentIndex < 3 ? 90 : (currentIndex < 6 ? 100 : 120);
            const camHeight = 35 + currentIndex * 3;
            
            camera.position.x = Math.sin(t * 0.15) * camRadius;
            camera.position.z = Math.cos(t * 0.15) * camRadius;
            camera.position.y = camHeight + Math.sin(t * 0.08) * 8;
            camera.lookAt(0, 0, 0);
            
            // Update label positions
            updateLabels();
            
            renderer.render(scene, camera);
        }
        
        function updateLabels() {
            labelTracking.forEach(track => {
                if (!track.object || !track.element) return;
                
                // Get 3D world position
                const pos = new THREE.Vector3();
                track.object.getWorldPosition(pos);
                
                // Apply offset if specified
                if (track.offset) {
                    pos.x += track.offset.x || 0;
                    pos.y += track.offset.y || 0;
                    pos.z += track.offset.z || 0;
                }
                
                // Project to screen space
                pos.project(camera);
                
                // Convert to screen coordinates
                const x = (pos.x * 0.5 + 0.5) * window.innerWidth;
                const y = (-pos.y * 0.5 + 0.5) * window.innerHeight;
                
                // Check if object is in front of camera
                if (pos.z < 1) {
                    track.element.style.left = x + 'px';
                    track.element.style.top = y + 'px';
                    track.element.style.opacity = '1';
                } else {
                    track.element.style.opacity = '0';
                }
            });
        }
        
        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function onKey(e) {
            if (isRecording) return; // Disable manual navigation during recording
            
            if (e.key === 'ArrowRight' || e.key === ' ') {
                loadStage((currentIndex + 1) % stages.length);
            } else if (e.key === 'ArrowLeft') {
                loadStage((currentIndex - 1 + stages.length) % stages.length);
            }
        }
        
        function toggleRecording() {
            if (!isRecording) {
                startRecording();
            } else {
                stopRecording();
            }
        }
        
        async function startRecording() {
            const canvas = document.getElementById('canvas');
            const btn = document.getElementById('recordBtn');
            
            // Check if screen capture is supported
            if (!navigator.mediaDevices || !navigator.mediaDevices.getDisplayMedia) {
                alert('Screen recording is not supported in your browser. Please use Chrome, Edge, or Firefox.');
                return;
            }
            
            try {
                // Request screen capture with audio disabled
                const displayStream = await navigator.mediaDevices.getDisplayMedia({
                    video: {
                        width: 1920,
                        height: 1080,
                        frameRate: 60
                    },
                    audio: false
                });
                
                recordedChunks = [];
            
                // Use VP9 codec if available, otherwise VP8 or default
                const options = { mimeType: 'video/webm;codecs=vp9' };
                if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                    options.mimeType = 'video/webm;codecs=vp8';
                    if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                        options.mimeType = 'video/webm';
                    }
                }
                
                mediaRecorder = new MediaRecorder(displayStream, options);
                
                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        recordedChunks.push(event.data);
                    }
                };
                
                mediaRecorder.onstop = () => {
                    displayStream.getTracks().forEach(track => track.stop());
                    
                    const blob = new Blob(recordedChunks, { type: 'video/webm' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'topological_acoustics_visualization.webm';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    btn.textContent = '⏺ Start Recording';
                    btn.classList.remove('recording');
                    isRecording = false;
                };
                
                mediaRecorder.start();
                isRecording = true;
                recordingStartTime = Date.now();
                btn.textContent = '⏹ Recording...';
                btn.classList.add('recording');
                
                // Show timer
                const timerEl = document.getElementById('recordingTimer');
                timerEl.classList.add('active');
                
                // Start auto-advancing through stages
                currentIndex = 0;
                loadStage(0);
                stageStartTime = Date.now();
                updateTimer();
                autoAdvanceStages();
                
            } catch (err) {
                console.error('Error starting recording:', err);
                alert('Recording cancelled or failed. Please make sure you select "This Tab" when prompted.');
                btn.textContent = '⏺ Start Recording';
                btn.classList.remove('recording');
                isRecording = false;
            }
        }
        
        function updateTimer() {
            if (!isRecording) return;
            
            const timerEl = document.getElementById('recordingTimer');
            const elapsed = Date.now() - stageStartTime;
            const remaining = Math.ceil((stageDuration - elapsed) / 1000);
            
            if (remaining >= 0) {
                timerEl.textContent = `Stage ${currentIndex + 1}/${stages.length} | ${remaining}s remaining`;
                timerInterval = setTimeout(updateTimer, 100);
            }
        }
        
        function autoAdvanceStages() {
            if (!isRecording) return;
            
            autoAdvanceTimer = setTimeout(() => {
                currentIndex++;
                
                if (currentIndex < stages.length) {
                    loadStage(currentIndex);
                    stageStartTime = Date.now(); // Reset timer for new stage
                    updateTimer(); // Update timer display
                    autoAdvanceStages(); // Continue to next stage
                } else {
                    // Finished all stages
                    stopRecording();
                }
            }, stageDuration);
        }
        
        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
            }
            if (autoAdvanceTimer) {
                clearTimeout(autoAdvanceTimer);
                autoAdvanceTimer = null;
            }
            if (timerInterval) {
                clearTimeout(timerInterval);
                timerInterval = null;
            }
            
            // Hide timer
            const timerEl = document.getElementById('recordingTimer');
            timerEl.classList.remove('active');
        }
        
        init();
    </script>
</body>
</html>
